!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("three")):"function"==typeof define&&define.amd?define(["three"],t):"object"==typeof exports?exports.tacoxdna=t(require("three")):e.tacoxdna=t(e.THREE)}(self,(function(e){return(()=>{"use strict";var t={807:t=>{t.exports=e}},s={};function n(e){var o=s[e];if(void 0!==o)return o.exports;var i=s[e]={exports:{}};return t[e](i,i.exports,n),i.exports}n.d=(e,t)=>{for(var s in t)n.o(t,s)&&!n.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};return(()=>{n.r(o),n.d(o,{Logger:()=>l,convertFromTo:()=>T,convertFromTo_async:()=>E});var e=n(807);const t={0:"A",1:"G",2:"C",3:"T"},s={A:0,a:0,G:1,g:1,C:2,c:2,T:3,t:3,U:3,u:3,D:4};let i;try{i=Number.EPSILON}catch(e){i=2220446049250313e-31}const a=.4+.2,r=.3897628551303122;class l{static log(e,t=l.INFO,s){void 0===t&&(t=l.INFO),t<l.debug_level||(null!=s&&l.debug_level===l.DEBUG?l.logFunction(`${l.messages[t]}: ${e} (additional info: '${s}')`):l.logFunction(`${l.messages[t]}: ${e}`))}static die(e){throw l.log(e,l.CRITICAL),e}}l.DEBUG=0,l.INFO=1,l.WARNING=2,l.CRITICAL=3,l.debug_level=l.INFO,l.messages=["DEBUG","INFO","WARNING","CRITICAL"],l.logFunction=console.log;class c{constructor(t,n,o,i,a=new e.Vector3(0,0,0),r=new e.Vector3(0,0,0),d=-1,h,u,_){if(this.index=c.index,c.index++,this.cm_pos=t.clone(),this._a1=n.clone().normalize(),this._a3=o.clone().normalize(),"string"==typeof i)try{i=s[i]}catch(e){l.log(`Invalid base (${e})`)}this._base=i,this._L=r,this._v=a,this.n3=d,this.next=-1,this.pair=h,this.cluster=u,this.color=_}get pos_base(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(.4))}get pos_stack(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(.34))}get pos_back(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(-.4))}get pos_back_rel(){return this.pos_back.clone().sub(this.cm_pos)}get a2(){return this._a3.clone().cross(this._a1)}copy(e,t){let s=new c(this.cm_pos.clone(),this._a1.clone(),this._a3.clone(),this._base,this._L,this._v,this.n3,this.pair,this.cluster,this.color);return void 0!==e&&s.translate(e),void 0!==t&&s.rotate(t),s}translate(e){this.cm_pos.add(e),this.cm_pos_box.add(e)}rotate(e,t){void 0===t&&(t=this.cm_pos.clone()),this.cm_pos.sub(t).applyMatrix3(e).add(t),this._a1.applyMatrix3(e),this._a3.applyMatrix3(e)}distance(e,t=!0,s){t&&void 0===s&&l.die("distance between nucleotides: if PBC is true, box must be provided");let n=e.pos_back.clone().sub(this.pos_back);return t&&n.sub(s.clone().multiply(n.clone().divide(s).round())),n}get_base(){return[0,1,2,3].includes(this._base)?t[this._base]:this._base.toString()}_get_lorenzo_output(){return[this.cm_pos,this._a1,this._a3,this._v,this._L].map((e=>e.toArray().join(" "))).join(" ")}}c.index=0;class d{constructor(){this.index=d.index,d.index++,this._first=-1,this._last=-1,this._nucleotides=[],this._sequence=[],this._circular=!1}get N(){return this._nucleotides.length}get sequence(){return this._sequence}_prepare(e,t){this.index=e,this._first=t;let s=0;for(;s<this.N;)this._nucleotides[s].index=t+s,s++;return this._last=t+s,t+s+1}copy(){let e=new d;for(const t of this._nucleotides)e.add_nucleotide(t.copy());return e}get cm_pos(){let t=new e.Vector3;return this._nucleotides.forEach((e=>{t.add(e.cm_pos)})),t.divideScalar(this.N)}set cm_pos(e){const t=e.clone().sub(this.cm_pos);this._nucleotides.forEach((e=>e.translate(t)))}translate(e){let t=this.cm_pos.clone().add(e);this.cm_pos=t}rotate(e,t){void 0===t&&(t=this.cm_pos);for(const s of this._nucleotides)s.rotate(e,t)}append(e){let t=this._nucleotides.slice(-1)[0].distance(e._nucleotides[0],!1);Math.sqrt(t.dot(t))>1.0025&&l.log("WARNING: Strand.push(): strands seem too far apart. Assuming you know what you are doing.");let s=new d;for(const e of this._nucleotides)s.add_nucleotide(e);for(const t of e._nucleotides)s.add_nucleotide(t);return s}get_slice(e=0,t){if(void 0===t&&(t=this.N),t>this.N)throw`The given end parameter is larger than the number of nucleotides of the strand (${t} > ${this.N})`;let s=new d;for(let n=e;n<t;n++)s.add_nucleotide(this._nucleotides[n].copy());return s}set sequence(e){if("string"==typeof e&&(e=Array.from(e).map((e=>s[e]))),e.length==this._nucleotides.length){for(let t=0;t<this._nucleotides.length;t++)this._nucleotides[t]._base=e[t];this._sequence=e}else l.log("Cannot change sequence: lengths don't match",l.WARNING)}bring_in_box_nucleotides(e){let t=this.cm_pos.divide(e).round().multiply(e);for(const e of this._nucleotides)e.cm_pos_box=e.cm_pos.clone().sub(t)}add_nucleotide(e){0===this._nucleotides.length&&(this._first=e.index),e.strand=this.index,this._nucleotides.push(e),this._last=e.index,this._sequence.push(e._base)}_get_lorenzo_output(){let e=this._nucleotides.map((e=>e._get_lorenzo_output())).join("\n")+"\n",t="";for(const e of this._nucleotides){let s,n;this._circular?(s=e.index===this._first?this._last:e.index-1,n=e.index===this._last?this._first:e.index+1):(s=e.index===this._first?-1:e.index-1,n=e.index===this._last?-1:e.index+1),t+=`${this.index+1} ${e.get_base()} ${s} ${n}\n`}return[e,t]}get_lammps_N_of_bonds_strand(){let e=0;for(const t of this._nucleotides)(t.index!=this._last||this._circular)&&e++;return e}get_lammps_bonds(){let e=[];for(const t of this._nucleotides)t.index!=this._last?e.push(`${t.index+1}  ${t.index+2}`):this._circular&&e.push(`${t.index+1}  ${this._first+1}`);return e}make_circular(e=!1){if(e){let e=this._nucleotides.slice(-1)[0].distance(this._nucleotides[0],!1);Math.sqrt(e.dot(e))>1.0025&&l.log("Strand.make_circular(): ends of the strand seem too far apart. Assuming you know what you are doing.",l.WARNING)}this._circular=!0}make_noncircular(){this._circular=!1}is_circular(){return this._circular}cut_in_two(e=!0){let t=new d,s=new d,n=0;for(const o of this._nucleotides)n<this._nucleotides.length/2?t.add_nucleotide(e?o.copy():o):s.add_nucleotide(e?o.copy():o),n++;return[t,s]}}d.index=0;class h{constructor(e,t=0,s=0,n=0){this._time=t,this._ready=!1,this._box=e,this._N=0,this._N_strands=0,this._strands=[],this._nucleotide_to_strand=[],this.E_pot=s,this.E_kin=n,this.E_tot=s+n,c.index=0,d.index=0}get sequences(){return this._strands.map((e=>e._sequence))}get N(){return this._N}get N_strands(){return this._N_strands}_prepare(){let e=0;for(let t=0;t<this._N_strands;t++)e=this._strands[t]._prepare(t,e);for(const e of this._strands)e.bring_in_box_nucleotides(this._box)}copy(){let e=new h(this._box);for(const t of this._strands)e.add_strand(t.copy());return e}join(t,s){if(void 0===s){s=new e.Vector3(0,0,0);for(let e=0;e<3;e++)t._box[e]>this._box[e]?s[e]=t._box[e]:s[e]=this._box[e]}let n=new h(s);for(const e of this._strands)n.add_strand(e.copy());for(const e of t._strands)n.add_strand(e.copy());return n}add_strand(e){return this._strands.push(e),this._N+=e.N,this._N_strands++,!0}add_strands(e){if(Array.isArray(e)){let t=[];for(const s of e)this.add_strand(s)&&t.push(s);if(t.length===e.length)return!0;for(const e of t)c.index-=e.N,d.index--,this._strands.pop(),this._N-=e.N,this._N_strands--;return!1}return!!this.add_strand(e)}rotate(e,t){for(const s of this._strands)s.rotate(e,t)}translate(e){for(const t of this._strands)t.translate(e)}print_lorenzo_output(){let e=`t = ${this._time}\nb = ${this._box.x} ${this._box.y} ${this._box.z}\nE = ${this.E_tot} ${this.E_pot} ${this.E_kin}\n`,t=0,s=0;for(const e of this._strands)t++,s+=e.N;let n=`${s} ${t}\n`;for(const t of this._strands){let[s,o]=t._get_lorenzo_output();n+=o,e+=s}return[n,e]}print_oxview_output(){let e={box:this._box.toArray(),systems:[{id:0,strands:[]}]};for(const t of this._strands){let s={id:t.index,end3:t._nucleotides[0].index,end5:t._nucleotides.slice(-1)[0].index,class:"NucleicAcidStrand",monomers:[]};for(let e=0;e<t.N;e++){let n,o,i=t._nucleotides[e];t._circular?(o=0===e?t._nucleotides.slice(-1)[0].index:t._nucleotides[e-1].index,n=e===t._nucleotides.length-1?t._nucleotides[0].index:t._nucleotides[e+1].index):(o=0===e?-1:t._nucleotides[e-1].index,n=e===t._nucleotides.length-1?-1:t._nucleotides[e+1].index);let a={id:i.index,type:i.get_base(),class:"DNA",p:i.cm_pos.toArray(),a1:i._a1.toArray(),a3:i._a3.toArray()};o>=0&&(a.n3=o),n>=0&&(a.n5=n),void 0!==i.pair&&(a.bp=i.pair.index),void 0!==i.cluster&&(a.cluster=i.cluster),void 0!==i.color&&(a.color=i.color),s.monomers.push(a)}e.systems[0].strands.push(s)}return JSON.stringify(e)}get _nucleotides(){return[].concat(...this._strands.map((e=>e._nucleotides)))}map_nucleotides_to_strands(){for(let e=0;e<this._strands.length;e++)for(let t=0;t<this._strands[e].N;t++)this._nucleotide_to_strand.push(e)}print_dot_bracket_output(){let e="";for(let t=0;t<this.N;t++){let s=this._nucleotides[t].interactions;s.length>1&&l.log("more than 1 HB for a nucleotide",l.WARNING),0===s.length?e+=".":s[0]>t?e+="(":s[0]<t?e+=")":l.log("unexpected interaction detected while building nupack string",l.CRITICAL)}return e}}function u(...e){return e.reduce(((e,t)=>e+t),0)}function _(e,t,s=1){void 0===t&&(t=e,e=0);let n=[];for(let o=e;o<t;o+=s)n.push(o);return n}function p(e,t,s=1){void 0===t&&(t=e,e=0);var n=[];for(let o=0;o<s;o++)n[o]=e+Math.floor(Math.random()*(t-e));return 1===s?n[0]:n}function f(e,t){if(e===t)return!0;if(null===e||null===t)return!1;if(e.length!==t.length)return!1;for(var s=0;s<e.length;++s)if(e[s]!==t[s])return!1;return!0}function g(e,t,s){e=e.clone(),t=t.clone(),s=s.clone();const n=e.dot(e),o=t.dot(e);t.sub(e.clone().multiplyScalar(o/n));const i=s.dot(e),a=s.dot(t),r=t.dot(t);return s.sub(e.clone().multiplyScalar(i/n).add(t.clone().multiplyScalar(a/r))),e.divideScalar(n),t.divideScalar(r),s.divideScalar(Math.sqrt(s.dot(s))),[e,t,s]}function m(){let t,s,n=1;for(;n>=1;)t=1-2*Math.random(),s=1-2*Math.random(),n=t*t+s*s;const o=2*Math.sqrt(1-n);return new e.Vector3(t*o,s*o,1-2*n)}function b(){let[t,s,n]=g(m(),m(),m()),o=(new e.Matrix3).set(t.x,t.y,t.z,s.x,s.y,s.z,n.x,n.y,n.z);return o.determinant()<0&&(o=(new e.Matrix3).set(s.x,s.y,s.z,t.x,t.y,t.z,n.x,n.y,n.z)),o}class y{generate(t,n,o=new e.Vector3(0,0,0),i=new e.Vector3(0,0,1),h,u=0,_=!0,p=!1,f=0,g=10.34,m,b,y=!1){if("string"==typeof n)try{n=Array.from(n).map((e=>s[e]))}catch(e){l.die("Key Error: sequence is invalid")}let x=e=>Math.floor(Math.random()*e);if(void 0===n){n=new Array(t);for(let e=0;e<t;e++)n[e]=x(4)}else if(n.length!=t){let e=t-n.length;for(l.log(`sequence is too short, adding ${e} random bases`,l.WARNING);e--;)n.push(x(4))}p&&t<30&&l.log("sequence is too short! Proceed at your own risk",l.WARNING);let w=!0;p&&t<30&&!_&&(l.log("sequence is too short! Generating ssDNA without imposed helicity",l.WARNING),y||(w=!1)),void 0===m&&(m=0),void 0===b&&(b=t),m>b&&l.die("ds_end > ds_start"),b>t&&l.die("ds_end > bp");let M,v=Math.sqrt(i.dot(i));v<1e-10?(l.log("direction must be a valid vector, defaulting to (0, 0, 1)",l.WARNING),i=new e.Vector3(0,0,1)):i.divideScalar(v),h?M=h:(M=new e.Vector3(Math.random(),Math.random(),Math.random()),M.sub(i.clone().multiplyScalar(i.clone().dot(M))),M.normalize());let N,I,A,$=new d,V=M.clone().applyAxisAngle(i,u),q=o.clone(),k=i;if(p&&(N=M.clone().cross(i),I=2*Math.PI/t,A=.7525/Math.sqrt(2*(1-Math.cos(I)))),p&&w){for(let e=0;e<t;e++){let s=M.clone().multiplyScalar(r*Math.cos(e*I)).add(i.clone().multiplyScalar(r*Math.sin(e*I)));q.add(s),k=s.clone().normalize(),V=k.clone().cross(N),V.applyAxisAngle(k,e*(Math.round(Math.floor(t/g))+f)/t*2*Math.PI),$.add_nucleotide(new c(q.clone().sub(V.clone().multiplyScalar(a)),V,k,n[e]))}$.make_circular(!0)}else if(p&&!w){for(let s=0;s<t;s++)q=new e.Vector3(Math.cos(s*I)*A+.34*Math.cos(s*I),Math.sin(s*I)*A+.34*Math.sin(s*I),0),V=new e.Vector3(Math.cos(s*I),Math.sin(s*I),0),$.add_nucleotide(new c(q,V,new e.Vector3(0,0,1),n[s]));$.make_circular(!0)}else for(let e=0;e<t;e++)$.add_nucleotide(new c(q.clone().sub(V.clone().multiplyScalar(a)),V,k,n[e])),e!=t-1&&(V.applyAxisAngle(i,35.9*Math.PI/180),q.add(k.multiplyScalar(r)));if(_){let e=new d;for(let t=b-1;t<=m;t--){let s=$._nucleotides[t];V=s._a1.clone().negate(),k=s._a3.clone().negate();let o=V.clone().multiplyScalar(-1.2).add(s.cm_pos);e.add_nucleotide(new c(o,V,k,3-n[t]))}return 0===m&&b===t&&p&&e.make_circular(!0),[$,e]}return $}generate_or_sq(t,s,n=new e.Vector3(0,0,0),o=new e.Vector3(0,0,1),i,h=!0,u=0,_=Math.PI/180*33.75,f=[],g=[],m=[]){if(f&&g.length!=m.length&&(m.length+1===g.length?(l.log(`the lengths of begin ${g.length} and end ${m.length} arrays are mismatched; I will try to proceed by using the number of basepairs as the last element of the end array`,l.WARNING),m.push(t+1)):l.die(`the lengths of begin ${g.length} and end ${m.length} arrays are unrecoverably mismatched`)),void 0===s)s=p(0,4,t);else if(s.length!=t){let e=t-s.length;s+=p(0,4,e),l.log(`sequence is too short, adding ${e} random bases`,l.WARNING)}if(Array.isArray(_))_.length!=t-1&&l.log("generate_or_sq: incorrect angle array length, should be 1 less than number of base pairs",l.CRITICAL);else{let e=_;_=[];for(let s=0;s<t;s++)_.push(e)}let b=s.map((e=>3-e));b.reverse();let y,x=Math.sqrt(o.dot(o));x<1e-10?(l.log("direction must be a valid vector, defaulting to (0, 0, 1)",l.WARNING),o=new e.Vector3(0,0,1)):o.divideScalar(x),void 0===i?(y=new e.Vector3(Math.random(),Math.random(),Math.random()),y.sub(o.clone().multiplyScalar(o.clone().dot(y))),y.normalize()):y=i.clone();let w=new d,M=y.clone().applyAxisAngle(o,u),v=n.clone(),N=o.clone(),I=[];for(let n=0;n<t;n++)if(w.add_nucleotide(new c(v.clone().sub(M.clone().multiplyScalar(a)),M,N,s[n])),n!=t-1){let t=(new e.Quaternion).setFromAxisAngle(o,_[n]);if(I.push(t),M.applyQuaternion(t).normalize(),v.add(N.clone().normalize().multiplyScalar(r)),f)for(let e=0;e<f.length;e++)n>=g[e]&&n<m[e]&&f[e]&&v.add(N.clone().multiplyScalar(r*(-f[e]/(m[e]-g[e]))))}if(h){M.negate().normalize(),N=o.clone().negate().normalize();let e=new d;for(let s=0;s<t;s++){let n=w._nucleotides[t-s-1],o=new c(v.clone().sub(M.clone().multiplyScalar(a)),M.clone(),N.clone(),b[s],void 0,void 0,void 0,n);if(n.pair=o,e.add_nucleotide(o),s!=t-1&&(M.applyQuaternion(I.pop().conjugate()).normalize(),v.add(N.clone().multiplyScalar(r)),f))for(let e=0;e<f.length;e++)t-2-s>=g[e]&&t-2-s<m[e]&&f[e]&&v.add(N.clone().multiplyScalar(r*(-f[e]/(m[e]-g[e]))))}return[w,e]}return w}generate_double_offset(t,n,o,i=new e.Vector3(0,0,0),a=new e.Vector3(0,0,1),r,l=0){let c,d;c="string"==typeof t?[...t].map((e=>s[e])):t,d="string"==typeof n?[...n].map((e=>s[e])):n;let h=Math.max(c.length,d.length+o),u=this.generate(h,void 0,i,a,!1,void 0,!0),_=u[0],p=u[1];return _=_.get_slice(0,c.length),p=d.length+o>c.length?p.get_slice(0,d.length):p.get_slice(h-o-d.length,d.length),_.sequence=c,p.sequence=d,[_,p]}generate_rw(t,s=new e.Vector3(0,0,0)){l.log("Generating strand as a random walk. Remember to equilibrate the configuration with MC",l.WARNING);let n=new e.Vector3(.7525,0,0),o=s,i=[];i.push(o);for(let e=1;e<t.length;e++){let e,t=!0;for(;t;){t=!1;let s=b(),a=n.clone().applyMatrix3(s);e=o.clone().add(n.clone().applyMatrix3(s)),t=!1;for(const s of i)a=e.clone().sub(s),a.dot(a)<.4*.4&&(t=!0)}o=e,i.push(o)}let a=[];n=i[1].clone().sub(i[0]),a.push(n.clone().divideScalar(Math.sqrt(n.dot(n))));for(let e=1;e<i.length-1;e++)n=i[e+1].clone().add(i[e-1]).multiplyScalar(.5),n=i[e].clone().sub(n),a.push(n.clone().divideScalar(Math.sqrt(n.dot(n))));n=i[i.length-1].clone().sub(i[i.length-2]),a.push(n.divideScalar(Math.sqrt(n.dot(n))));let r=new d;for(let e=0;e<i.length;e++){let s=i[e],[n,o,l]=g(a[e],m(),m()),d=s+a[e]*Math.abs(-.4);r.add_nucleotide(new c(d,n,l,t[e]))}return r}}class x{constructor(){this.map=new Map}set(e,t){this.map.set(e.toString(),t)}get(e){return this.map.get(e.toString())}has(e){return this.map.has(e.toString())}get size(){return this.map.size}*keys(){for(let e of this.map.keys())yield e.split(",").map((e=>parseInt(e)))}*entries(){for(let[e,t]of this.map.entries()){let s=e.split(",").map((e=>parseInt(e)));yield[s,t]}}values(){return this.map.values()}}class w extends x{constructor(){super(),this._scaf=new x,this._stap=new x,this.nuc_count=0,this.strand_count=0}add_scaf(e,t,s,n){this._scaf.set([e,t],[s,n])}add_stap(e,t,s,n){this._stap.set([e,t],[s,n])}add_scaf_strand(e,t,s=!1){let n=0;const o=this._scaf.size;for(const[[s,o],[i,a]]of t._scaf.entries())i===e&&(this.add_scaf(s,o,this.strand_count,a.map((e=>e+this.nuc_count))),n+=a.length);return this.nuc_count+=n,this._scaf.size===o?1:(s||this.strand_count++,0)}add_stap_strand(e,t,s=!1){let n=0;const o=this._stap.size;for(const[[s,o],[i,a]]of t._stap.entries())i===e&&(this.add_stap(s,o,this.strand_count,a.map((e=>e+this.nuc_count))),n+=a.length);return this.nuc_count+=n,this._stap.size===o?1:(s||this.strand_count++,0)}add_strand(e,t,s=!1){return this.add_scaf_strand(e,t,s)&&this.add_stap_strand(e,t,s)}}const M=2.55,v=2.6;class N{constructor(){this.begin=[],this.end=[]}toString(){return`${this.begin} ${this.end}`}add_begin(e){this.begin.includes(e)||this.begin.push(e)}add_end(e){this.end.includes(e)||this.end.push(e)}}function I(e,t,s,n,o,i,a,r,c,d,h,_,p,f){let g,m,b=0,x=0;if((t.num%2+_)%2==0){for(const e of t.skip.slice(0,s))b-=e;for(const e of t.skip.slice(0,n+1))x-=e;for(const e of t.loop.slice(0,s))b+=e;for(const e of t.loop.slice(0,n+1))x+=e;g=s+b,m=n+1+x}else{for(const e of t.skip.slice(n))x-=e;for(const e of t.skip.slice(s+1))b-=e;for(const e of t.loop.slice(n))x+=e;for(const e of t.loop.slice(s+1))b+=e;g=t.len-s-1+b,m=t.len-n+x}let w=function(e,t,s,n,o,i,a,r,c){let d,h=[],_=0,p=new N,f=[],g=o.slice();i.num%2==1&&(d=new N,d.begin=a.begin.slice().reverse(),d.end=a.end.slice().reverse());for(let e=0;e<a.begin.length;e++){let t,s,n,r;if(i.num%2==0?(t=a.begin[e],r=a.end[e],s=a.begin[e],n=a.end[e]):(t=d.end[e],r=d.begin[e],s=i.len-d.begin[e]-1,n=i.len-d.end[e]-1),n-s!=0){h.push(0);for(const s of i.skip.slice(t,r+1))h[e]-=s;for(const s of i.loop.slice(t,r+1))h[e]+=s;f.push(u(...o.slice(s,n))/(n-s+h[e]));for(let t=s;t<n;t++)g[t]=f[e];s+=_,n+=_+h[e],p.add_begin(s),p.add_end(n)}else h.push(0),f.push(u(...o)/o.length),s+=_,n+=_+h[e],p.add_begin(s),p.add_end(n);_+=h[e]}let m=0,b=0,x=0,w=0;for(let e=0;e<a.begin.length;e++){let t,s,n,o;m+=x,b+=w,x=0,w=0,i.num%2==0?(t=a.begin[e],s=a.end[e],n=a.begin[e],o=a.end[e]):(t=d.end[e],s=d.begin[e],n=i.len-d.begin[e]-1,o=i.len-d.end[e]-1);for(const e of i.skip.slice(t,s+1))1===e&&(g.splice(n-m+b,1),x++);for(const o of i.loop.slice(t,s+1))for(let t=0;t<o;t++)g.splice(n-m+b,0,f[e]),w++}let M=(new y).generate_or_sq(g.length+1,void 0,e,t,s,!0,n,g,h,p.begin,p.end);if(r){let e;try{e=c[i.cad_index].map((e=>e))}catch(e){l.die("sequence file contains too few rows compared to the number of virtual helices in the cadnano file, dying")}i.num%2==1&&e.reverse(),M[0].N!=e.length?l.log(`Cannot change sequence: lengths don't match; virtual helix ${i.num}, sequence length ${e.length}, virtual helix length ${M[0].N} - are skips/loops accounted for?`,l.WARNING):M[0].sequence=e;let t=e.map((e=>3-e));t.reverse(),M[0].N!=e.length?l.log(`Cannot change sequence: lengths don't match; virtual helix ${i.num}, sequence length ${e.length}, virtual helix length ${M[0].N} - are skips/loops accounted for?`,l.WARNING):M[1].sequence=t}return M}(a,r,c,d,h,t,o,p,f);return e.add_strand(w[_].get_slice(g,m)),e}function A(e,t,s,n,o,i){let a,r=0,l=0,c=0;if((e.num%2+i)%2==0){for(const t of e.skip.slice(s,n+1))r-=t;for(const t of e.loop.slice(s,n+1))r+=t}else{for(const t of e.skip.slice(n,s+1))r-=t;for(const t of e.loop.slice(n,s+1))r+=t}a=(i+e.num%2)%2==0?n-s+1+r:s+1-n+r;let d=0;for(;d<a;){let n;if(n=(i+e.num%2)%2==0?d+s+l-c:s-d-l+c,1!=e.skip[n]){let s;s=(i+e.num%2)%2==0?_(e.loop[n]+1).map((e=>d+e)):_(e.loop[n]+1).reverse().map((e=>d+e)),0===i?o.set([e.num,n],[t,[d]]):1===i?o.set([t,d],[e.num,[n]]):2===i?o.add_scaf(e.num,n,t,s):3===i&&o.add_stap(e.num,n,t,s),d+=1+e.loop[n],c+=e.loop[n]}else 2===i?o.add_scaf(e.num,n,t,[]):3===i&&o.add_stap(e.num,n,t,[]),l++}return o}function $(e){let t=new N,s=-1;e.num%2==0&&(s=1);for(let n=0;n<e.scaf.length;n++){let o,i,a,r,l=n-1*s,c=n+1*s;_(e.scaf.length).includes(l)?(o=e.scaf[l].type(e,l),i=e.stap[l].type(e,l)):(o=!1,i=!1),_(e.scaf.length).includes(c)?(a=e.scaf[c].type(e,c),r=e.stap[c].type(e,c)):(a=!1,r=!1),(o!==i||"begin"!==o&&"end"!==o)&&(a!==r||"begin"!==a&&"end"!==a)&&("empty"===e.scaf[n].type(e,n)?"begin"===e.stap[n].type(e,n)?t.add_end(n):"end"===e.stap[n].type(e,n)&&t.add_begin(n):"begin"===e.scaf[n].type(e,n)?"empty"===e.stap[n].type(e,n)?t.add_begin(n):"continue"===e.stap[n].type(e,n)?(t.add_begin(n),t.add_end(n-1*s)):"begin"===e.stap[n].type(e,n)?(t.add_begin(n+1*s),t.add_end(n-1*s)):"end"===e.stap[n].type(e,n)&&t.add_begin(n):"end"===e.scaf[n].type(e,n)?"empty"===e.stap[n].type(e,n)?t.add_end(n):"continue"===e.stap[n].type(e,n)?(t.add_begin(n+1*s),t.add_end(n)):"begin"===e.stap[n].type(e,n)?t.add_end(n):"end"===e.stap[n].type(e,n)&&(t.add_begin(n+1*s),t.add_end(n-1*s)):"continue"===e.scaf[n].type(e,n)&&("begin"===e.stap[n].type(e,n)?(t.add_begin(n+1*s),t.add_end(n)):"end"===e.stap[n].type(e,n)&&(t.add_begin(n),t.add_end(n-1*s))))}return t}function V(t,s,n){let o=new y,i=new Array(n.len-1);for(let e=0;e<i.length;e++){let t=e%32;t<2?i[e]=28*Math.PI/180:2===t?i[e]=36*Math.PI/180:3===t?i[e]=54.375*Math.PI/180:4===t?i[e]=37*Math.PI/180:[5,6].includes(t)?i[e]=27.6666666666666*Math.PI/180:7===t?i[e]=30.6666666666666*Math.PI/180:[8,9].includes(t)?i[e]=29.3333333333*Math.PI/180:10===t?i[e]=34.3333333333*Math.PI/180:11===t?i[e]=54.5*Math.PI/180:[12,13].includes(t)?i[e]=28.91666666666*Math.PI/180:[14,15,16,17].includes(t)?i[e]=31.16666666666*Math.PI/180:18===t?i[e]=35.5*Math.PI/180:19===t?i[e]=52*Math.PI/180:20===t?i[e]=35.5*Math.PI/180:[21,22].includes(t)?i[e]=27.5*Math.PI/180:i[e]=23===t?35.5*Math.PI/180:t>=24&&t<27?30*Math.PI/180:27===t?52*Math.PI/180:28===t?35.5*Math.PI/180:Math.PI/180*30.91666666666}let a,l,c,d,h,_=0;for(let e=0;e<31;e++)_+=i[e];for(let e=0;e<i.length;e++)e%32==31&&(i[e]=1080*Math.PI/180-_);return n.num%2==0?(a=new e.Vector3(n.col*v,n.row*v,0),l=t.clone(),c=s.clone(),d=0,h=i.slice()):(a=new e.Vector3(n.col*v,n.row*v,(n.len-1)*r),l=t.clone().negate(),c=s.clone().negate(),d=-u(...i)%(2*Math.PI),h=i.slice().reverse()),[o.generate_or_sq(n.len,void 0,a,l,c,!0,d,h),i,a,d,l,c]}function q(t,s,n){let o=new y,i=new Array(n.len-1);for(let e=0;e<i.length;e++){const t=e%21;0===t?i[e]=32.571*Math.PI/180:1===t?i[e]=36*Math.PI/180:[1,2,3].includes(t)?i[e]=42*Math.PI/180:[5,6,7].includes(t)?i[e]=29.143*Math.PI/180:8===t?i[e]=32*Math.PI/180:[9,10].includes(t)?i[e]=44*Math.PI/180:[12,13,14].includes(t)?i[e]=28.571*Math.PI/180:[16,17].includes(t)?i[e]=41.5*Math.PI/180:[19,20].includes(t)?i[e]=28.476*Math.PI/180:i[e]=720/21*(Math.PI/180)}let a,l,c,d,h,_=0;for(let e=0;e<20;e++)_+=i[e];for(let e=0;e<i.length;e++)e%21==20&&(i[e]=720*Math.PI/180-_);if(n.num%2==0)a=new e.Vector3(n.col*Math.sqrt(3)*M/2,3*n.row*M/2,0),l=t.clone(),c=s.clone(),d=0,h=o.generate_or_sq(n.len,void 0,a,l,c,!0,d,i);else{a=new e.Vector3(n.col*Math.sqrt(3)*M/2,3*n.row*M/2+1.275,(n.len-1)*r),l=t.clone().negate(),c=s.clone().negate(),d=-u(...i)%(2*Math.PI);let _=i.slice().reverse();h=o.generate_or_sq(n.len,void 0,a,l,c,!0,d,_)}return[h,i,a,d,l,c]}class k{constructor(){this.vhelices=[]}add_vhelix(e){this.vhelices.push(e)}bbox(){let e=[],t=[],s=[];for(const n of this.vhelices)e.push(n.row),t.push(n.col),s.push(n.stap.length);const n=v*(Math.max(...e)-Math.min(...e)+2),o=v*(Math.max(...t)-Math.min(...t)+2),i=.34*(Math.max(...s)+2);return 2*Math.max(n,o,i)*2}toString(){let e='{\n"vstrands":[\n';if(this.vhelices.length>0){for(const t of this.vhelices)e+=`${t},`;e=e.slice(0,e.length-1)}return e+="}\n",e}}class S{constructor(){this.stapLoop=[],this.scafLoop=[],this.skip=[],this.loop=[],this.stap_colors=[],this.row=0,this.col=0,this.num=0,this.stap=[],this.scaf=[],this.cad_index=-1,this.skiploop_bases=0}get len(){return Math.max(this.scaf.length,this.stap.length)}add_square(e,t){"stap"===t?this.stap.push(e):"scaf"===t?this.scaf.push(e):l.log("Cannot add square that is not scaf or stap. Dying now",l.CRITICAL)}toString(){let e="{\n";if(e+='"stapLoop":[',this.stapLoop.length>0){for(const t of this.stapLoop)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"skip":[',this.skip.length>0){for(const t of this.skip)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"loop":[',this.loop.length>0){for(const t of this.loop)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"stap_colors":[',this.stap_colors.length>0){for(const t of this.stap_colors)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+=`"row":${this.row},\n`,e+=`"col":${this.col},\n`,e+=`"num":${this.num},\n`,e+='"scafLoop":[',this.scafLoop.length>0){for(const t of this.scafLoop)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"stap":[',this.stap.length>0){for(const t of this.stap)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"scaf":[',this.scaf.length>0){for(const t of this.scaf)e+=`${t},`;e=e.slice(0,e.length-1)}return e+="]\n}",e}}class P{constructor(e=-1,t=-1,s=-1,n=-1){this.V_0=e,this.b_0=t,this.V_1=s,this.b_1=n}toString(){return`[${this.V_0},${this.b_0},${this.V_1},${this.b_1}]`}type(e,t){if(-1===this.V_0&&-1===this.b_0){if(-1===this.V_1&&-1===this.b_1)return"empty";if(this.V_1===e.num&&1===Math.abs(this.b_1-t))return"begin"}else{if(this.V_0===e.num&&1===Math.abs(this.b_0-t))return-1===this.V_1?"end":this.V_1===e.num&&1===Math.abs(this.b_1-t)?"continue":"end";if(this.V_1===e.num&&1===Math.abs(this.b_1-t))return"begin"}l.log("unexpected square array",l.WARNING)}}function C(e,t,s){let n=.4*parseFloat(s)/2;return e.clone().sub(t.clone().multiplyScalar(n))}const R=1/8.518,G=new Map([["ADE","A"],["CYT","C"],["GUA","G"],["THY","T"],["URA","U"]]),W=["A","T","G","C","U"];let z=!1;class O{constructor(e,t){this.name=e.trim(),[...G.keys()].includes(this.name)?this.base=G[this.name]:this.name in W?("U"!=this.name||z||(l.log("WARNING: unsupported uracil detected: use at your own risk"),z=!0),this.base=this.name):this.base=e.slice(1),this.idx=t,this.base_atoms=[],this.phosphate_atoms=[],this.sugar_atoms=[],this.named_atoms={},this.ring_names=["C2","C4","C5","C6","N1","N3"]}get atoms(){return[].concat(this.base_atoms,this.phosphate_atoms,this.sugar_atoms)}add_atom(e){e.name.includes("P")||"HO5'"==e.name?this.phosphate_atoms.push(e):e.name.includes("'")?this.sugar_atoms.push(e):this.base_atoms.push(e),this.named_atoms[e.name]=e,void 0===this.chain_id&&(this.chain_id=e.chain_id)}get_com(t){null==t&&(t=this.atoms);let s=new e.Vector3(0,0,0);for(const e of t)s.add(e.pos);return s.divideScalar(t.length)}compute_a3(){const t=this.get_com(this.base_atoms),s=this.named_atoms["O4'"].pos.clone().sub(t);this.a3=new e.Vector3(0,0,0);for(const e of function*(e,t){let s=Array.from(e),n=s.length;if(3>n)return;let o=Array.from(_(n)),i=Array.from(_(n,n-3,-1)),a=e=>s[e];for(yield o.slice(0,3).map(a);n>0;){let e=!0;for(let t of _(2,-1,-1)){if(i[t]-=1,0!==i[t]){let s=i[t],[n,r]=[o[o.length-s],o[t]];o[t]=n,o[o.length-s]=r,yield o.slice(0,3).map(a),e=!1;break}o=o.slice(0,t).concat(o.slice(t+1)).concat(o.slice(t,t+1)),i[t]=n-t}if(e)return}}(this.ring_names)){let t=this.named_atoms[e[0]],n=this.named_atoms[e[1]],o=this.named_atoms[e[2]],i=t.pos.clone().sub(n.pos),a=t.pos.clone().sub(o.pos);if(i.divideScalar(Math.sqrt(i.dot(i))),a.divideScalar(Math.sqrt(a.dot(a))),Math.abs(i.dot(a))>.01){let e=i.clone().cross(a);e.divideScalar(Math.sqrt(e.dot(e))),e.dot(s)<0&&e.negate(),this.a3.add(e)}}this.a3.divideScalar(Math.sqrt(this.a3.dot(this.a3)))}compute_a1(){let t;t=this.name.includes("C")||this.name.includes("T")||this.name.includes("U")?[["N3","C6"],["C2","N1"],["C4","C5"]]:[["N1","C4"],["C2","N3"],["C6","C5"]],this.a1=new e.Vector3(0,0,0);for(const e of t){let t=this.named_atoms[e[0]],s=this.named_atoms[e[1]],n=t.pos.clone().sub(s.pos);this.a1.add(n)}this.a1.divideScalar(Math.sqrt(this.a1.dot(this.a1)))}compute_as(){this.compute_a1(),this.compute_a3(),this.a2=this.a3.clone().cross(this.a1),this.check=Math.abs(this.a1.dot(this.a3))}correct_for_large_boxes(e){for(const s of this.atoms)s.shift((t=s.pos/e,-Math.sign(t)*Math.round(Math.abs(t))*e));var t}to_pdb(e,t,s,n,o){let i,a,r,l,c=[];for(const l of this.atoms)if(t||!l.name.includes("H")){if("5"==o){if("P"in l.name){"P"==l.name&&(i=l);continue}"O5'"==l.name&&(a=l)}else"3"==o&&"O3'"==l.name&&(r=l);c.push(l.to_pdb(e,s,n))}if("5"==o){let t=i.clone();t.name="HO5'";let o=i.pos.sub(l.pos);o.multiplyScalar(1/Math.sqrt(o.dot(o))),t.pos=l.pos.clone().add(o),c.push(t.to_pdb(e,s,n))}else if("3"==o){let t=r.clone();t.name="HO3'";let o=this.a2.clone().multiplyScalar(.2).sub(this.a1.clone().multiplyScalar(.2)).sub(this.a3);o.multiplyScalar(1/Math.sqrt(o.dot(o))),t.pos=r.pos.clone().add(o),c.push(t.to_pdb(e,s,n))}return c.join("\n")}to_mgl(){let e=[];for(const t of this.atoms)e.push(t.to_mgl());return e.join("\n")}rotate(e){let t=this.get_com();for(const s of this.atoms)s.pos=e.dot(s.pos.clone().sub(t)).add(t);this.compute_as()}set_com(e){let t=this.get_com();for(const s of this.atoms)s.pos.add(e.sub(t).sub(this.a1.clone().multiplyScalar(.5)))}}class F{constructor(t){this.name=t.slice(12,16).trim(),this.name.includes("*")&&(this.name=this.name.replace("*","'")),this.alternate=t[16],this.residue=t.slice(17,20).trim(),this.chain_id=t.slice(21,22).trim(),this.residue_idx=parseInt(t.slice(22,26)),this.pos=new e.Vector3(parseFloat(t.slice(30,38)),parseFloat(t.slice(38,46)),parseFloat(t.slice(46,54)))}clone(){let e=new F("");return e.name=this.name.slice(),e.alternate=this.alternate.slice(),e.residue=this.residue.slice(),e.chain_id=this.chain_id.slice(),e.residue_idx=this.residue_idx,e.pos=this.pos.clone(),e}is_hydrogen(){this.name.includes("H")}shift(e){this.pos.add(e)}to_pdb(e,t,s){let n=this.residue+s,o=(e,t)=>`${e}`.padStart(t," "),i=`ATOM  ${o(F.serial_atom,5)} ${o(this.name,4)} ${o(n,3)} ${o(e,3)}${o(t,1)}    ${o(this.pos.x.toFixed(3),8)}${o(this.pos.y.toFixed(3),8)}${o(this.pos.z.toFixed(3),8)}  1.00  0.00              `;return F.serial_atom++,F.serial_atom>99999&&(F.serial_atom=1),i}}function T(t,s,n,o){let i;switch(s){case"cadnano":i=function(t,s,n,o){let i=!1,a=!1;if("sq"===s)i=!0;else{if("he"!==s)return void alert("Lattice_type should be either 'sq' or 'he'");a=!0}let r=new w,g=new w,m=function(e){let t=new k,s=JSON.parse(e);for(const e of s.vstrands){let s=new S;for(const[t,n]of Object.entries(e))"skip"===t?s.skip=n.map((e=>Math.abs(e))):s[t]="stap"===t||"scaf"===t?n.map((e=>new P(...e))):n;s.skiploop_bases=s.skip.length+u(...s.loop)-u(...s.skip),t.add_vhelix(s)}return t}(t),b=!1,y=!0;if(!n){l.log("No sequences given, using random sequence",l.INFO),n=[];for(let e=0;e<m.vhelices.length;e++){let t=[];for(let s=0;s<m.vhelices[e].skiploop_bases;s++)t.push(p(0,4));n.push(t)}}1===n.length&&m.vhelices.length>1&&(l.log("One line detected in the sequence file. Since the cadnano file contains more than 1 virtual helix, the sequence found will be used as we were dealing with a single-strand system",l.INFO),b=!0,y=!1);let M=0;void 0===o&&(o=m.bbox(),l.log("Using default box size, a factor 2 larger than the size of the cadnano system",l.INFO));let v=new e.Vector3(0,0,1),N=new e.Vector3(1,0,0);var C;i?(C=v,N=N.clone().applyAxisAngle(C,15*Math.PI/180)):a&&(N=function(e,t){return t.clone().applyAxisAngle(e,160*Math.PI/180)}(v,N));let R=new h(new e.Vector3(o,o,o)),G=new h(new e.Vector3(o,o,o)),W=-1,z=[],O=[],F=!1,T=[],E=[],L=-1,j=-1;for(const e of m.vhelices){let t,s,o,c,d,h;e.cad_index=M,i?[t,s,o,c,d,h]=V(v,N,e):a&&([t,s,o,c,d,h]=q(v,N,e));let u=$(e),_=0;for(const t of e.scaf){if(-1===t.V_0&&-1===t.b_0)-1===t.V_1&&-1===t.b_0||(t.V_1===e.num&&1===Math.abs(t.b_1-_)?(e.num%2==0&&W++,L=_,e.num%2==1&&(R=I(R,e,L,j,u,0,o,d,h,c,s,0,y,n),r=A(e,W,L,j,r,2))):l.log("unexpected square array",l.WARNING));else if(t.V_0===e.num&&1===Math.abs(t.b_0-_))if(-1===t.V_1&&-1===t.b_1)e.num%2==1&&W++,j=_,e.num%2==0&&(R=I(R,e,L,j,u,0,o,d,h,c,s,0,y,n),r=A(e,W,L,j,r,2));else if(t.V_1===e.num&&1===Math.abs(t.b_1-_));else{let i;e.num%2==1&&W++,j=_,e.num%2==0&&(R=I(R,e,L,j,u,0,o,d,h,c,s,0,y,n),r=A(e,W,L,j,r,2)),e.num,i=_;for(let t=0;t<z.length;t++)f([e.num,i],z[t])&&(T[t].splice(0,0,W),F=!0);F||(T.push([W]),z.push([t.V_1,t.b_1])),F=!1}else if(-1===t.V_1&&-1===t.b_1)l.log("unexpected square array",l.WARNING);else if(t.V_1===e.num&&1===Math.abs(t.b_1-_)){e.num%2==0&&W++,L=_,e.num%2==1&&(R=I(R,e,L,j,u,0,o,d,h,c,s,0,y,n),r=A(e,W,L,j,r,2));for(let t=0;t<z.length;t++){let s;e.num,s=_,f([e.num,s],z[t])&&(T[t].push(W),F=!0)}F||(T.push([W]),z.push([t.V_0,t.b_0])),F=!1}else l.log("unexpected square array",l.WARNING);_++}if(0!==R.N_strands){_=0;for(const t of e.stap){if(-1===t.V_0&&-1===t.b_0)-1===t.V_1&&-1===t.b_0||(t.V_1===e.num&&1===Math.abs(t.b_1-_)?(e.num%2==1&&W++,L=_,e.num%2==0&&(R=I(R,e,L,j,u,0,o,d,h,c,s,1,y,n),r=A(e,W,L,j,r,3))):l.log("unexpected square array",l.WARNING));else if(t.V_0===e.num&&1===Math.abs(t.b_0-_))if(-1===t.V_1&&-1===t.b_1)e.num%2==0&&W++,j=_,e.num%2==1&&(R=I(R,e,L,j,u,0,o,d,h,c,s,1,y,n),r=A(e,W,L,j,r,3));else if(t.V_1===e.num&&1===Math.abs(t.b_1-_));else{e.num%2==0&&W++,j=_,e.num%2==1&&(R=I(R,e,L,j,u,0,o,d,h,c,s,1,y,n),r=A(e,W,L,j,r,3));let i=_;for(let t=0;t<O.length;t++)f([e.num,i],O[t])&&(E[t].splice(0,0,W),F=!0);F||(E.push([W]),O.push([t.V_1,t.b_1])),F=!1}else if(-1===t.V_1&&-1===t.b_1)l.log("unexpected square array",l.WARNING);else if(t.V_1===e.num&&1===Math.abs(t.b_1-_)){e.num%2==1&&W++,L=_,e.num%2==0&&(R=I(R,e,L,j,u,0,o,d,h,c,s,1,y,n),r=A(e,W,L,j,r,3));for(let t=0;t<O.length;t++){let s=_;f([e.num,s],O[t])&&(E[t].push(W),F=!0)}F||(E.push([W]),O.push([t.V_0,t.b_0])),F=!1}else l.log("unexpected square array",l.WARNING);_++}M++}else l.log(`No scaffold strand found in virtual helix n. ${e.num}: staples-only virtual helices are not supported`,l.WARNING)}let D,U=[T,E],H=[];for(let e=0;e<2;e++)for(const t of U[e])H.push(...t);for(let e=0;e<R._strands.length;e++)H.includes(e)||(G.add_strand(R._strands[e]),g.add_strand(e,r));for(let e=0;e<2;e++){const t=U[e];let s=!1;D=!1;for(const e of t){let t=R._strands[e[0]],s=R._strands[e[1]],n=t._nucleotides.slice(-1)[0].distance(s._nucleotides[0],!1),o=Math.sqrt(n.dot(n));(o>1.0018||o<.5525)&&l.log(`The backbone-backbone distance across joints is ${o}: it will have to be relaxed with preliminary simulations`,l.WARNING)}let o=[];for(;!s;){D=!1;for(let e=0;e<t.length&&!D;e++)for(let s=0;s<t.length&&!D;s++)if(t[e][0]===t[s].slice(-1)[0]){if(e!=s){t[s].push(...t[e].slice(1)),t.splice(e,1),D=!0;break}o.includes(e)||o.push(e)}D||(s=!0)}for(let e=0;e<t.length;e++){const s=t[e];let i,a=R._strands[s[0]];if(o.includes(e)){for(const e of _(1,s.length-1))a=a.append(R._strands[s[e]]);a.make_circular(!0)}else for(const e of _(1,s.length))a=a.append(R._strands[s[e]]);G.add_strand(a),i=a._circular?_(s.length-2):_(s.length-1);for(const e of i)g.add_strand(s[e],r,!0);g.add_strand(s[i[i.length-1]+1],r,!1),b&&(G._strands[0].sequence=n[0])}}let B=new h(G._box);for(const e of G._strands){let t=e._nucleotides.map((e=>e));t.reverse();let s=new d;for(const e of t)s.add_nucleotide(new c(e.cm_pos,e._a1,e._a3.clone().negate(),e._base));e._circular&&s.make_circular(),B.add_strand(s)}let Q=new w,J=_(B._N_strands),Y=0;for(let e=0;e<B._strands.length;e++){const t=B._strands[e];J[e]=Y,Y+=t._nucleotides.length}let K=new Map;for(const[e,t]of g._scaf.keys()){let[s,n]=g._scaf.get([e,t]),o=[];for(const i of n){const n=B._strands[s]._nucleotides.length-1-(i-J[s])+J[s];o.push(n),K.set(n,[e,t])}Q.add_scaf(e,t,s,o)}for(const[e,t]of g._stap.keys()){let[s,n]=g._stap.get([e,t]),o=[];for(const i of n){const n=B._strands[s]._nucleotides.length-1-(i-J[s])+J[s];o.push(n),K.set(n,[e,t])}Q.add_stap(e,t,s,o)}if(0===B.N)return void l.log("The generated configuration is empty: this might be due to this conversion module not supporting virtual helices containing no scaffold strands.",l.CRITICAL);let X=new x;for(const e of m.vhelices)for(const[t,s]of e.stap_colors)X.set([e.num,t],s);let Z=new x;for(const[e,t]of K.entries())Z.has(t)||Z.set(t,[]),Z.get(t).push(e);let ee=new Map;for(const e of B._strands)for(const t of e._nucleotides)ee.set(t.index,t);let te=[];for(const e of Z.values())for(const t of e)try{te.push(ee.get(t).strand)}catch(e){console.log(`Could not find nucId ${t} strand`)}let se=(ne=te,oe={},ne.forEach((function(e){oe[e]=(oe[e]||0)+1})),Object.keys(oe).reduce((function(e,t,s){return!s||oe[t]>oe[e[0]]?[t]:(oe[t]===oe[e[0]]&&e.push(t),e)}),[]))[0];var ne,oe;let ie=new Map;for(const e of B._strands)for(const t of e._nucleotides)if(K.has(t.index)){let[e,s]=K.get(t.index),n=Z.get([e,s]);n.length>1&&(t.pair=ee.get(n.filter((e=>e!=t.index))[0]));let o=Z.get([e,s]).filter((e=>ee.get(e).strand!=se));if(o.length>0){let n=ee.get(o[0]);const i=[e,n.strand];ie.has(i)||ie.set(i,ie.size+1),t.cluster=ie.get(i),t===n?X.has([e,s])&&(t.color=X.get([e,s])):t.color=3633362}else t.cluster=-1}for(const e of B._strands)for(const t of e._nucleotides)if(void 0!==t.color){for(const s of e._nucleotides)s.color=t.color;break}return B}(t[0],o.grid,o.sequences,o.side);break;case"rpoly":i=function(t){let s=[],n=[],o=[],i=0;for(const e of t.split("\n"))e.startsWith("hb")?(s.splice(i,0,e.split(" ")),i+=1):e.startsWith("c")&&(e.includes("f3")?o.push([parseInt(e.match(/c helix_(.+?) /)[1]),parseInt(e.match(/\' helix_(.+?) /)[1])]):n.push([parseInt(e.match(/c helix_(.+?) /)[1]),parseInt(e.match(/\' helix_(.+?) /)[1])]));let a=new y,r=new h(new e.Vector3(100,100,100)),l=new h(new e.Vector3(100,100,100)),c=0;for(let t=0;t<s.length;t++){const n=s[t];let o=new e.Vector3(parseFloat(n[3])/.84,parseFloat(n[4])/.84,parseFloat(n[5])/.84),i=parseInt(n[2]),d=new e.Quaternion(parseFloat(n[6]),parseFloat(n[7]),parseFloat(n[8]),parseFloat(n[9])),h=new e.Vector3(0,0,1).applyQuaternion(d),u=new e.Vector3(.65,-.76,0).applyQuaternion(d),_=C(o,h,i);for(const e of _.toArray())e>c&&(c=e);let p=a.generate_or_sq(i,void 0,_,h,u);for(const e of[0,1])for(const s of p[e]._nucleotides)s.cluster=t+1;let[f,g]=p[1].cut_in_two(!1);r.add_strand(f),r.add_strand(g),l.add_strand(p[0])}let d=new h(new e.Vector3(3*c,3*c,3*c));for(const e of n){let t=2*e[0]-1,s=2*e[1]-2,n=r._strands[t];n=n.append(r._strands[s]),d.add_strand(n)}let u=l._strands[0];for(const e of o.slice(0,-1)){let t=e[1]-1,s=l._strands[t];u=u.append(s)}return u.make_circular(),d.add_strand(u),d}(t[0]);break;case"pdb":i=function(t,s,n){let o,i,a,r=[],u=[];for(let e of t.split("\n")){e=e.trim();let t=new F(e);if(e.startsWith("ATOM"))""!==i&&(t.chain_id!==i&&0!==u.length?(l.log(`WARNING: a TER statement separating different strands (${t.chain_id} and ${i}) is missing`),r.push(u),u=[]):t.chain_id===i&&0===u.length&&l.log(`WARNING: a TER statement separates strands having the same chain id (${t.chain_id})`)),""!==t.alternate&&("A"!==t.alternate&&"1"!==t.alternate||l.log(`Alternate location for atom '${t.name}' of residue '${t.residue}' encountered, using the line marked with the '${t.alternate}' character.`)),t.residue_idx!==o&&(a=new O(t.residue,t.residue_idx),s?u.push(a):u.splice(0,0,a),o=t.residue_idx),a.add_atom(t),i=t.chain_id;else if(e.startsWith("MODEL")){if(!n){let t=e.split(" ")[1];l.log(`MODEL line detected: using the first MODEL encountered (${t})`)}}else if(e.startsWith("ENDMDL")){if(!n)break;u.length>0&&(r.push(u),u=[])}else(e.startsWith("TER")||"END"===e&&0===r.length&&u.length>0)&&(r.push(u),u=[])}u.length>0&&r.push(u);let _=new e.Vector3(1e6,1e6,1e6),p=new e.Vector3(-1e6,-1e6,-1e6);for(const e of[].concat(...r)){let t=e.get_com();for(let e=0;e<3;e++)t.getComponent(e)<_.getComponent(e)?_.setComponent(e,t.getComponent(e)):t.getComponent(e)>p.getComponent(e)&&p.setComponent(e,t.getComponent(e))}let f=2*Math.max(...p.clone().sub(_).toArray())*R;f=Math.ceil(f);let g=new e.Vector3(f,f,f);l.log(`Using a box of size ${f} in oxDNA units (twice as big as the PDB bounding box size)`);let m=new h(g);for(const e of r){let t=new d;for(const s of e){s.compute_as();let e=s.get_com().clone().multiplyScalar(R),n=new c(e,s.a1,s.a3,s.base[0]);t.add_nucleotide(n)}m.add_strand(t)}return m}(t[0],o.strand_dir,o.models_as_strands);break;default:return void console.log("Unknown input format: "+s)}switch(n){case"oxview":return i.print_oxview_output();case"oxdna":return i.print_lorenzo_output();default:console.log("Unknown output format: "+s)}}async function E(e,t,s,n){const o=new Worker("./src/libs/conversionWorker",{type:"module"});return new Promise(((i,a)=>{try{o.onmessage=e=>{i(e.data),o.terminate()},o.onerror=e=>{a(e),o.terminate()},o.postMessage([e,t,s,n])}catch(e){a(e)}}))}F.serial_atom=1})(),o})()}));