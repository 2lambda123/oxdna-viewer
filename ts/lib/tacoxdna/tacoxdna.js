!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("three")):"function"==typeof define&&define.amd?define(["three"],t):"object"==typeof exports?exports.tacoxdna=t(require("three")):e.tacoxdna=t(e.THREE)}(self,(function(e){return(()=>{"use strict";var t={807:t=>{t.exports=e}},n={};function s(e){var o=n[e];if(void 0!==o)return o.exports;var i=n[e]={exports:{}};return t[e](i,i.exports,s),i.exports}s.d=(e,t)=>{for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};return(()=>{s.r(o),s.d(o,{Logger:()=>l,convertFromTo:()=>z,convertFromTo_async:()=>G});var e=s(807);const t={0:"A",1:"G",2:"C",3:"T"},n={A:0,a:0,G:1,g:1,C:2,c:2,T:3,t:3,U:3,u:3,D:4};let i;try{i=Number.EPSILON}catch(e){i=2220446049250313e-31}const r=.4+.2,a=.3897628551303122;class l{static log(e,t=l.INFO,n){void 0===t&&(t=l.INFO),t<l.debug_level||(null!=n&&l.debug_level===l.DEBUG?l.logFunction(`${l.messages[t]}: ${e} (additional info: '${n}')`):l.logFunction(`${l.messages[t]}: ${e}`))}static die(e){throw l.log(e,l.CRITICAL),e}}l.DEBUG=0,l.INFO=1,l.WARNING=2,l.CRITICAL=3,l.debug_level=l.INFO,l.messages=["DEBUG","INFO","WARNING","CRITICAL"],l.logFunction=console.log;class c{constructor(t,s,o,i,r=new e.Vector3(0,0,0),a=new e.Vector3(0,0,0),d=-1,h,u,_){if(this.index=c.index,c.index++,this.cm_pos=t.clone(),this._a1=s.clone().normalize(),this._a3=o.clone().normalize(),"string"==typeof i)try{i=n[i]}catch(e){l.log(`Invalid base (${e})`)}this._base=i,this._L=a,this._v=r,this.n3=d,this.next=-1,this.pair=h,this.cluster=u,this.color=_}get pos_base(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(.4))}get pos_stack(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(.34))}get pos_back(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(-.4))}get pos_back_rel(){return this.pos_back.clone().sub(this.cm_pos)}get a2(){return this._a3.clone().cross(this._a1)}copy(e,t){let n=new c(this.cm_pos.clone(),this._a1.clone(),this._a3.clone(),this._base,this._L,this._v,this.n3,this.pair,this.cluster,this.color);return void 0!==e&&n.translate(e),void 0!==t&&n.rotate(t),n}translate(e){this.cm_pos.add(e),this.cm_pos_box.add(e)}rotate(e,t){void 0===t&&(t=this.cm_pos.clone()),this.cm_pos.sub(t).applyMatrix3(e).add(t),this._a1.applyMatrix3(e),this._a3.applyMatrix3(e)}distance(e,t=!0,n){t&&void 0===n&&l.die("distance between nucleotides: if PBC is true, box must be provided");let s=e.pos_back.clone().sub(this.pos_back);return t&&s.sub(n.clone().multiply(s.clone().divide(n).round())),s}get_base(){return[0,1,2,3].includes(this._base)?t[this._base]:this._base.toString()}_get_lorenzo_output(){return[this.cm_pos,this._a1,this._a3,this._v,this._L].map((e=>e.toArray().join(" "))).join(" ")}}c.index=0;class d{constructor(){this.index=d.index,d.index++,this._first=-1,this._last=-1,this._nucleotides=[],this._sequence=[],this._circular=!1}get N(){return this._nucleotides.length}get sequence(){return this._sequence}_prepare(e,t){this.index=e,this._first=t;let n=0;for(;n<this.N;)this._nucleotides[n].index=t+n,n++;return this._last=t+n,t+n+1}copy(){let e=new d;for(const t of this._nucleotides)e.add_nucleotide(t.copy());return e}get cm_pos(){let t=new e.Vector3;return this._nucleotides.forEach((e=>{t.add(e.cm_pos)})),t.divideScalar(this.N)}set cm_pos(e){const t=e.clone().sub(this.cm_pos);this._nucleotides.forEach((e=>e.translate(t)))}translate(e){let t=this.cm_pos.clone().add(e);this.cm_pos=t}rotate(e,t){void 0===t&&(t=this.cm_pos);for(const n of this._nucleotides)n.rotate(e,t)}append(e){let t=this._nucleotides.slice(-1)[0].distance(e._nucleotides[0],!1);Math.sqrt(t.dot(t))>1.0025&&l.log("WARNING: Strand.push(): strands seem too far apart. Assuming you know what you are doing.");let n=new d;for(const e of this._nucleotides)n.add_nucleotide(e);for(const t of e._nucleotides)n.add_nucleotide(t);return n}get_slice(e=0,t){if(void 0===t&&(t=this.N),t>this.N)throw`The given end parameter is larger than the number of nucleotides of the strand (${t} > ${this.N})`;let n=new d;for(let s=e;s<t;s++)n.add_nucleotide(this._nucleotides[s].copy());return n}set sequence(e){if("string"==typeof e&&(e=Array.from(e).map((e=>n[e]))),e.length==this._nucleotides.length){for(let t=0;t<this._nucleotides.length;t++)this._nucleotides[t]._base=e[t];this._sequence=e}else l.log("Cannot change sequence: lengths don't match",l.WARNING)}bring_in_box_nucleotides(e){let t=this.cm_pos.divide(e).round().multiply(e);for(const e of this._nucleotides)e.cm_pos_box=e.cm_pos.clone().sub(t)}add_nucleotide(e){0===this._nucleotides.length&&(this._first=e.index),e.strand=this.index,this._nucleotides.push(e),this._last=e.index,this._sequence.push(e._base)}_get_lorenzo_output(){let e=this._nucleotides.map((e=>e._get_lorenzo_output())).join("\n")+"\n",t="";for(const e of this._nucleotides){let n,s;this._circular?(n=e.index===this._first?this._last:e.index-1,s=e.index===this._last?this._first:e.index+1):(n=e.index===this._first?-1:e.index-1,s=e.index===this._last?-1:e.index+1),t+=`${this.index+1} ${e.get_base()} ${n} ${s}\n`}return[e,t]}get_lammps_N_of_bonds_strand(){let e=0;for(const t of this._nucleotides)(t.index!=this._last||this._circular)&&e++;return e}get_lammps_bonds(){let e=[];for(const t of this._nucleotides)t.index!=this._last?e.push(`${t.index+1}  ${t.index+2}`):this._circular&&e.push(`${t.index+1}  ${this._first+1}`);return e}make_circular(e=!1){if(e){let e=this._nucleotides.slice(-1)[0].distance(this._nucleotides[0],!1);Math.sqrt(e.dot(e))>1.0025&&l.log("Strand.make_circular(): ends of the strand seem too far apart. Assuming you know what you are doing.",l.WARNING)}this._circular=!0}make_noncircular(){this._circular=!1}is_circular(){return this._circular}cut_in_two(e=!0){let t=new d,n=new d,s=0;for(const o of this._nucleotides)s<this._nucleotides.length/2?t.add_nucleotide(e?o.copy():o):n.add_nucleotide(e?o.copy():o),s++;return[t,n]}}d.index=0;class h{constructor(e,t=0,n=0,s=0){this._time=t,this._ready=!1,this._box=e,this._N=0,this._N_strands=0,this._strands=[],this._nucleotide_to_strand=[],this.E_pot=n,this.E_kin=s,this.E_tot=n+s,c.index=0,d.index=0}get sequences(){return this._strands.map((e=>e._sequence))}get N(){return this._N}get N_strands(){return this._N_strands}_prepare(){let e=0;for(let t=0;t<this._N_strands;t++)e=this._strands[t]._prepare(t,e);for(const e of this._strands)e.bring_in_box_nucleotides(this._box)}copy(){let e=new h(this._box);for(const t of this._strands)e.add_strand(t.copy());return e}join(t,n){if(void 0===n){n=new e.Vector3(0,0,0);for(let e=0;e<3;e++)t._box[e]>this._box[e]?n[e]=t._box[e]:n[e]=this._box[e]}let s=new h(n);for(const e of this._strands)s.add_strand(e.copy());for(const e of t._strands)s.add_strand(e.copy());return s}add_strand(e){return this._strands.push(e),this._N+=e.N,this._N_strands++,!0}add_strands(e){if(Array.isArray(e)){let t=[];for(const n of e)this.add_strand(n)&&t.push(n);if(t.length===e.length)return!0;for(const e of t)c.index-=e.N,d.index--,this._strands.pop(),this._N-=e.N,this._N_strands--;return!1}return!!this.add_strand(e)}rotate(e,t){for(const n of this._strands)n.rotate(e,t)}translate(e){for(const t of this._strands)t.translate(e)}print_lorenzo_output(){let e=`t = ${this._time}\nb = ${this._box.x} ${this._box.y} ${this._box.z}\nE = ${this.E_tot} ${this.E_pot} ${this.E_kin}\n`,t=0,n=0;for(const e of this._strands)t++,n+=e.N;let s=`${n} ${t}\n`;for(const t of this._strands){let[n,o]=t._get_lorenzo_output();s+=o,e+=n}return[s,e]}print_oxview_output(){let e={box:this._box.toArray(),systems:[{id:0,strands:[]}]};for(const t of this._strands){let n={id:t.index,end3:t._nucleotides[0].index,end5:t._nucleotides.slice(-1)[0].index,class:"NucleicAcidStrand",monomers:[]};for(let e=0;e<t.N;e++){let s,o,i=t._nucleotides[e];t._circular?(o=0===e?t._nucleotides.slice(-1)[0].index:t._nucleotides[e-1].index,s=e===t._nucleotides.length-1?t._nucleotides[0].index:t._nucleotides[e+1].index):(o=0===e?-1:t._nucleotides[e-1].index,s=e===t._nucleotides.length-1?-1:t._nucleotides[e+1].index);let r={id:i.index,type:i.get_base(),class:"DNA",p:i.cm_pos.toArray(),a1:i._a1.toArray(),a3:i._a3.toArray()};o>=0&&(r.n3=o),s>=0&&(r.n5=s),void 0!==i.pair&&(r.bp=i.pair.index),void 0!==i.cluster&&(r.cluster=i.cluster),void 0!==i.color&&(r.color=i.color),n.monomers.push(r)}e.systems[0].strands.push(n)}return JSON.stringify(e)}get _nucleotides(){return[].concat(...this._strands.map((e=>e._nucleotides)))}map_nucleotides_to_strands(){for(let e=0;e<this._strands.length;e++)for(let t=0;t<this._strands[e].N;t++)this._nucleotide_to_strand.push(e)}print_dot_bracket_output(){let e="";for(let t=0;t<this.N;t++){let n=this._nucleotides[t].interactions;n.length>1&&l.log("more than 1 HB for a nucleotide",l.WARNING),0===n.length?e+=".":n[0]>t?e+="(":n[0]<t?e+=")":l.log("unexpected interaction detected while building nupack string",l.CRITICAL)}return e}}function u(e,t,n=1){void 0===t&&(t=e,e=0);var s=[];for(let o=0;o<n;o++)s[o]=e+Math.floor(Math.random()*(t-e));return 1===n?s[0]:s}function _(e,t){if(e===t)return!0;if(null===e||null===t)return!1;if(e.length!==t.length)return!1;for(var n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}function p(e,t,n){e=e.clone(),t=t.clone(),n=n.clone();const s=e.dot(e),o=t.dot(e);t.sub(e.clone().multiplyScalar(o/s));const i=n.dot(e),r=n.dot(t),a=t.dot(t);return n.sub(e.clone().multiplyScalar(i/s).add(t.clone().multiplyScalar(r/a))),e.divideScalar(s),t.divideScalar(a),n.divideScalar(Math.sqrt(n.dot(n))),[e,t,n]}function f(){let t,n,s=1;for(;s>=1;)t=1-2*Math.random(),n=1-2*Math.random(),s=t*t+n*n;const o=2*Math.sqrt(1-s);return new e.Vector3(t*o,n*o,1-2*s)}function g(){let[t,n,s]=p(f(),f(),f()),o=(new e.Matrix3).set(t.x,t.y,t.z,n.x,n.y,n.z,s.x,s.y,s.z);return o.determinant()<0&&(o=(new e.Matrix3).set(n.x,n.y,n.z,t.x,t.y,t.z,s.x,s.y,s.z)),o}class m{generate(t,s,o=new e.Vector3(0,0,0),i=new e.Vector3(0,0,1),h,u=0,_=!0,p=!1,f=0,g=10.34,m,b,y=!1){if("string"==typeof s)try{s=Array.from(s).map((e=>n[e]))}catch(e){l.die("Key Error: sequence is invalid")}let x=e=>Math.floor(Math.random()*e);if(void 0===s){s=new Array(t);for(let e=0;e<t;e++)s[e]=x(4)}else if(s.length!=t){let e=t-s.length;for(l.log(`sequence is too short, adding ${e} random bases`,l.WARNING);e--;)s.push(x(4))}p&&t<30&&l.log("sequence is too short! Proceed at your own risk",l.WARNING);let w=!0;p&&t<30&&!_&&(l.log("sequence is too short! Generating ssDNA without imposed helicity",l.WARNING),y||(w=!1)),void 0===m&&(m=0),void 0===b&&(b=t),m>b&&l.die("ds_end > ds_start"),b>t&&l.die("ds_end > bp");let v,M=Math.sqrt(i.dot(i));M<1e-10?(l.log("direction must be a valid vector, defaulting to (0, 0, 1)",l.WARNING),i=new e.Vector3(0,0,1)):i.divideScalar(M),h?v=h:(v=new e.Vector3(Math.random(),Math.random(),Math.random()),v.sub(i.clone().multiplyScalar(i.clone().dot(v))),v.normalize());let N,I,A,V=new d,q=v.clone().applyAxisAngle(i,u),k=o.clone(),$=i;if(p&&(N=v.clone().cross(i),I=2*Math.PI/t,A=.7525/Math.sqrt(2*(1-Math.cos(I)))),p&&w){for(let e=0;e<t;e++){let n=v.clone().multiplyScalar(a*Math.cos(e*I)).add(i.clone().multiplyScalar(a*Math.sin(e*I)));k.add(n),$=n.clone().normalize(),q=$.clone().cross(N),q.applyAxisAngle($,e*(Math.round(Math.floor(t/g))+f)/t*2*Math.PI),V.add_nucleotide(new c(k.clone().sub(q.clone().multiplyScalar(r)),q,$,s[e]))}V.make_circular(!0)}else if(p&&!w){for(let n=0;n<t;n++)k=new e.Vector3(Math.cos(n*I)*A+.34*Math.cos(n*I),Math.sin(n*I)*A+.34*Math.sin(n*I),0),q=new e.Vector3(Math.cos(n*I),Math.sin(n*I),0),V.add_nucleotide(new c(k,q,new e.Vector3(0,0,1),s[n]));V.make_circular(!0)}else for(let e=0;e<t;e++)V.add_nucleotide(new c(k.clone().sub(q.clone().multiplyScalar(r)),q,$,s[e])),e!=t-1&&(q.applyAxisAngle(i,35.9*Math.PI/180),k.add($.multiplyScalar(a)));if(_){let e=new d;for(let t=b-1;t<=m;t--){let n=V._nucleotides[t];q=n._a1.clone().negate(),$=n._a3.clone().negate();let o=q.clone().multiplyScalar(-1.2).add(n.cm_pos);e.add_nucleotide(new c(o,q,$,3-s[t]))}return 0===m&&b===t&&p&&e.make_circular(!0),[V,e]}return V}generate_or_sq(t,n,s=new e.Vector3(0,0,0),o=new e.Vector3(0,0,1),i,h=!0,_=0,p=Math.PI/180*33.75,f=[],g=[],m=[]){if(f&&g.length!=m.length&&(m.length+1===g.length?(l.log(`the lengths of begin ${g.length} and end ${m.length} arrays are mismatched; I will try to proceed by using the number of basepairs as the last element of the end array`,l.WARNING),m.push(t+1)):l.die(`the lengths of begin ${g.length} and end ${m.length} arrays are unrecoverably mismatched`)),void 0===n)n=u(0,4,t);else if(n.length!=t){let e=t-n.length;n+=u(0,4,e),l.log(`sequence is too short, adding ${e} random bases`,l.WARNING)}if(Array.isArray(p))p.length!=t-1&&l.log("generate_or_sq: incorrect angle array length, should be 1 less than number of base pairs",l.CRITICAL);else{let e=p;p=[];for(let n=0;n<t;n++)p.push(e)}let b=n.map((e=>3-e));b.reverse();let y,x=Math.sqrt(o.dot(o));x<1e-10?(l.log("direction must be a valid vector, defaulting to (0, 0, 1)",l.WARNING),o=new e.Vector3(0,0,1)):o.divideScalar(x),void 0===i?(y=new e.Vector3(Math.random(),Math.random(),Math.random()),y.sub(o.clone().multiplyScalar(o.clone().dot(y))),y.normalize()):y=i.clone();let w=new d,v=y.clone().applyAxisAngle(o,_),M=s.clone(),N=o.clone(),I=[];for(let s=0;s<t;s++)if(w.add_nucleotide(new c(M.clone().sub(v.clone().multiplyScalar(r)),v,N,n[s])),s!=t-1){let t=(new e.Quaternion).setFromAxisAngle(o,p[s]);if(I.push(t),v.applyQuaternion(t).normalize(),M.add(N.clone().normalize().multiplyScalar(a)),f)for(let e=0;e<f.length;e++)s>=g[e]&&s<m[e]&&f[e]&&M.add(N.clone().multiplyScalar(a*(-f[e]/(m[e]-g[e]))))}if(h){v.negate().normalize(),N=o.clone().negate().normalize();let e=new d;for(let n=0;n<t;n++){let s=w._nucleotides[t-n-1],o=new c(M.clone().sub(v.clone().multiplyScalar(r)),v.clone(),N.clone(),b[n],void 0,void 0,void 0,s);if(s.pair=o,e.add_nucleotide(o),n!=t-1&&(v.applyQuaternion(I.pop().conjugate()).normalize(),M.add(N.clone().multiplyScalar(a)),f))for(let e=0;e<f.length;e++)t-2-n>=g[e]&&t-2-n<m[e]&&f[e]&&M.add(N.clone().multiplyScalar(a*(-f[e]/(m[e]-g[e]))))}return[w,e]}return w}generate_double_offset(t,s,o,i=new e.Vector3(0,0,0),r=new e.Vector3(0,0,1),a,l=0){let c,d;c="string"==typeof t?[...t].map((e=>n[e])):t,d="string"==typeof s?[...s].map((e=>n[e])):s;let h=Math.max(c.length,d.length+o),u=this.generate(h,void 0,i,r,!1,void 0,!0),_=u[0],p=u[1];return _=_.get_slice(0,c.length),p=d.length+o>c.length?p.get_slice(0,d.length):p.get_slice(h-o-d.length,d.length),_.sequence=c,p.sequence=d,[_,p]}generate_rw(t,n=new e.Vector3(0,0,0)){l.log("Generating strand as a random walk. Remember to equilibrate the configuration with MC",l.WARNING);let s=new e.Vector3(.7525,0,0),o=n,i=[];i.push(o);for(let e=1;e<t.length;e++){let e,t=!0;for(;t;){t=!1;let n=g(),r=s.clone().applyMatrix3(n);e=o.clone().add(s.clone().applyMatrix3(n)),t=!1;for(const n of i)r=e.clone().sub(n),r.dot(r)<.4*.4&&(t=!0)}o=e,i.push(o)}let r=[];s=i[1].clone().sub(i[0]),r.push(s.clone().divideScalar(Math.sqrt(s.dot(s))));for(let e=1;e<i.length-1;e++)s=i[e+1].clone().add(i[e-1]).multiplyScalar(.5),s=i[e].clone().sub(s),r.push(s.clone().divideScalar(Math.sqrt(s.dot(s))));s=i[i.length-1].clone().sub(i[i.length-2]),r.push(s.divideScalar(Math.sqrt(s.dot(s))));let a=new d;for(let e=0;e<i.length;e++){let n=i[e],[s,o,l]=p(r[e],f(),f()),d=n+r[e]*Math.abs(-.4);a.add_nucleotide(new c(d,s,l,t[e]))}return a}}class b{constructor(){this.map=new Map}set(e,t){this.map.set(e.toString(),t)}get(e){return this.map.get(e.toString())}has(e){return this.map.has(e.toString())}get size(){return this.map.size}*keys(){for(let e of this.map.keys())yield e.split(",").map((e=>parseInt(e)))}*entries(){for(let[e,t]of this.map.entries()){let n=e.split(",").map((e=>parseInt(e)));yield[n,t]}}values(){return this.map.values()}}class y extends b{constructor(){super(),this._scaf=new b,this._stap=new b,this.nuc_count=0,this.strand_count=0}add_scaf(e,t,n,s){this._scaf.set([e,t],[n,s])}add_stap(e,t,n,s){this._stap.set([e,t],[n,s])}add_scaf_strand(e,t,n=!1){let s=0;const o=this._scaf.size;for(const[[n,o],[i,r]]of t._scaf.entries())i===e&&(this.add_scaf(n,o,this.strand_count,r.map((e=>e+this.nuc_count))),s+=r.length);return this.nuc_count+=s,this._scaf.size===o?1:(n||this.strand_count++,0)}add_stap_strand(e,t,n=!1){let s=0;const o=this._stap.size;for(const[[n,o],[i,r]]of t._stap.entries())i===e&&(this.add_stap(n,o,this.strand_count,r.map((e=>e+this.nuc_count))),s+=r.length);return this.nuc_count+=s,this._stap.size===o?1:(n||this.strand_count++,0)}add_strand(e,t,n=!1){return this.add_scaf_strand(e,t,n)&&this.add_stap_strand(e,t,n)}}const x=2.55,w=2.6;function v(...e){return e.reduce(((e,t)=>e+t),0)}function M(e,t){void 0===t&&(t=e,e=0);let n=[];for(let s=e;s<t;s++)n.push(s);return n}class N{constructor(){this.begin=[],this.end=[]}toString(){return`${this.begin} ${this.end}`}add_begin(e){this.begin.includes(e)||this.begin.push(e)}add_end(e){this.end.includes(e)||this.end.push(e)}}function I(e,t,n,s,o,i,r,a,c,d,h,u,_,p){let f,g,b=0,y=0;if((t.num%2+u)%2==0){for(const e of t.skip.slice(0,n))b-=e;for(const e of t.skip.slice(0,s+1))y-=e;for(const e of t.loop.slice(0,n))b+=e;for(const e of t.loop.slice(0,s+1))y+=e;f=n+b,g=s+1+y}else{for(const e of t.skip.slice(s))y-=e;for(const e of t.skip.slice(n+1))b-=e;for(const e of t.loop.slice(s))y+=e;for(const e of t.loop.slice(n+1))b+=e;f=t.len-n-1+b,g=t.len-s+y}let x=function(e,t,n,s,o,i,r,a,c){let d,h=[],u=0,_=new N,p=[],f=o.slice();i.num%2==1&&(d=new N,d.begin=r.begin.slice().reverse(),d.end=r.end.slice().reverse());for(let e=0;e<r.begin.length;e++){let t,n,s,a;if(i.num%2==0?(t=r.begin[e],a=r.end[e],n=r.begin[e],s=r.end[e]):(t=d.end[e],a=d.begin[e],n=i.len-d.begin[e]-1,s=i.len-d.end[e]-1),s-n!=0){h.push(0);for(const n of i.skip.slice(t,a+1))h[e]-=n;for(const n of i.loop.slice(t,a+1))h[e]+=n;p.push(v(...o.slice(n,s))/(s-n+h[e]));for(let t=n;t<s;t++)f[t]=p[e];n+=u,s+=u+h[e],_.add_begin(n),_.add_end(s)}else h.push(0),p.push(v(...o)/o.length),n+=u,s+=u+h[e],_.add_begin(n),_.add_end(s);u+=h[e]}let g=0,b=0,y=0,x=0;for(let e=0;e<r.begin.length;e++){let t,n,s,o;g+=y,b+=x,y=0,x=0,i.num%2==0?(t=r.begin[e],n=r.end[e],s=r.begin[e],o=r.end[e]):(t=d.end[e],n=d.begin[e],s=i.len-d.begin[e]-1,o=i.len-d.end[e]-1);for(const e of i.skip.slice(t,n+1))1===e&&(f.splice(s-g+b,1),y++);for(const o of i.loop.slice(t,n+1))for(let t=0;t<o;t++)f.splice(s-g+b,0,p[e]),x++}let w=(new m).generate_or_sq(f.length+1,void 0,e,t,n,!0,s,f,h,_.begin,_.end);if(a){let e;try{e=c[i.cad_index].map((e=>e))}catch(e){l.die("sequence file contains too few rows compared to the number of virtual helices in the cadnano file, dying")}i.num%2==1&&e.reverse(),w[0].N!=e.length?l.log(`Cannot change sequence: lengths don't match; virtual helix ${i.num}, sequence length ${e.length}, virtual helix length ${w[0].N} - are skips/loops accounted for?`,l.WARNING):w[0].sequence=e;let t=e.map((e=>3-e));t.reverse(),w[0].N!=e.length?l.log(`Cannot change sequence: lengths don't match; virtual helix ${i.num}, sequence length ${e.length}, virtual helix length ${w[0].N} - are skips/loops accounted for?`,l.WARNING):w[1].sequence=t}return w}(r,a,c,d,h,t,o,_,p);return e.add_strand(x[u].get_slice(f,g)),e}function A(e,t,n,s,o,i){let r,a=0,l=0,c=0;if((e.num%2+i)%2==0){for(const t of e.skip.slice(n,s+1))a-=t;for(const t of e.loop.slice(n,s+1))a+=t}else{for(const t of e.skip.slice(s,n+1))a-=t;for(const t of e.loop.slice(s,n+1))a+=t}r=(i+e.num%2)%2==0?s-n+1+a:n+1-s+a;let d=0;for(;d<r;){let s;if(s=(i+e.num%2)%2==0?d+n+l-c:n-d-l+c,1!=e.skip[s]){let n;n=(i+e.num%2)%2==0?M(e.loop[s]+1).map((e=>d+e)):M(e.loop[s]+1).reverse().map((e=>d+e)),0===i?o.set([e.num,s],[t,[d]]):1===i?o.set([t,d],[e.num,[s]]):2===i?o.add_scaf(e.num,s,t,n):3===i&&o.add_stap(e.num,s,t,n),d+=1+e.loop[s],c+=e.loop[s]}else 2===i?o.add_scaf(e.num,s,t,[]):3===i&&o.add_stap(e.num,s,t,[]),l++}return o}function V(e){let t=new N,n=-1;e.num%2==0&&(n=1);for(let s=0;s<e.scaf.length;s++){let o,i,r,a,l=s-1*n,c=s+1*n;M(e.scaf.length).includes(l)?(o=e.scaf[l].type(e,l),i=e.stap[l].type(e,l)):(o=!1,i=!1),M(e.scaf.length).includes(c)?(r=e.scaf[c].type(e,c),a=e.stap[c].type(e,c)):(r=!1,a=!1),(o!==i||"begin"!==o&&"end"!==o)&&(r!==a||"begin"!==r&&"end"!==r)&&("empty"===e.scaf[s].type(e,s)?"begin"===e.stap[s].type(e,s)?t.add_end(s):"end"===e.stap[s].type(e,s)&&t.add_begin(s):"begin"===e.scaf[s].type(e,s)?"empty"===e.stap[s].type(e,s)?t.add_begin(s):"continue"===e.stap[s].type(e,s)?(t.add_begin(s),t.add_end(s-1*n)):"begin"===e.stap[s].type(e,s)?(t.add_begin(s+1*n),t.add_end(s-1*n)):"end"===e.stap[s].type(e,s)&&t.add_begin(s):"end"===e.scaf[s].type(e,s)?"empty"===e.stap[s].type(e,s)?t.add_end(s):"continue"===e.stap[s].type(e,s)?(t.add_begin(s+1*n),t.add_end(s)):"begin"===e.stap[s].type(e,s)?t.add_end(s):"end"===e.stap[s].type(e,s)&&(t.add_begin(s+1*n),t.add_end(s-1*n)):"continue"===e.scaf[s].type(e,s)&&("begin"===e.stap[s].type(e,s)?(t.add_begin(s+1*n),t.add_end(s)):"end"===e.stap[s].type(e,s)&&(t.add_begin(s),t.add_end(s-1*n))))}return t}function q(t,n,s){let o=new m,i=new Array(s.len-1);for(let e=0;e<i.length;e++){let t=e%32;t<2?i[e]=28*Math.PI/180:2===t?i[e]=36*Math.PI/180:3===t?i[e]=54.375*Math.PI/180:4===t?i[e]=37*Math.PI/180:[5,6].includes(t)?i[e]=27.6666666666666*Math.PI/180:7===t?i[e]=30.6666666666666*Math.PI/180:[8,9].includes(t)?i[e]=29.3333333333*Math.PI/180:10===t?i[e]=34.3333333333*Math.PI/180:11===t?i[e]=54.5*Math.PI/180:[12,13].includes(t)?i[e]=28.91666666666*Math.PI/180:[14,15,16,17].includes(t)?i[e]=31.16666666666*Math.PI/180:18===t?i[e]=35.5*Math.PI/180:19===t?i[e]=52*Math.PI/180:20===t?i[e]=35.5*Math.PI/180:[21,22].includes(t)?i[e]=27.5*Math.PI/180:i[e]=23===t?35.5*Math.PI/180:t>=24&&t<27?30*Math.PI/180:27===t?52*Math.PI/180:28===t?35.5*Math.PI/180:Math.PI/180*30.91666666666}let r,l,c,d,h,u=0;for(let e=0;e<31;e++)u+=i[e];for(let e=0;e<i.length;e++)e%32==31&&(i[e]=1080*Math.PI/180-u);return s.num%2==0?(r=new e.Vector3(s.col*w,s.row*w,0),l=t.clone(),c=n.clone(),d=0,h=i.slice()):(r=new e.Vector3(s.col*w,s.row*w,(s.len-1)*a),l=t.clone().negate(),c=n.clone().negate(),d=-v(...i)%(2*Math.PI),h=i.slice().reverse()),[o.generate_or_sq(s.len,void 0,r,l,c,!0,d,h),i,r,d,l,c]}function k(t,n,s){let o=new m,i=new Array(s.len-1);for(let e=0;e<i.length;e++){const t=e%21;0===t?i[e]=32.571*Math.PI/180:1===t?i[e]=36*Math.PI/180:[1,2,3].includes(t)?i[e]=42*Math.PI/180:[5,6,7].includes(t)?i[e]=29.143*Math.PI/180:8===t?i[e]=32*Math.PI/180:[9,10].includes(t)?i[e]=44*Math.PI/180:[12,13,14].includes(t)?i[e]=28.571*Math.PI/180:[16,17].includes(t)?i[e]=41.5*Math.PI/180:[19,20].includes(t)?i[e]=28.476*Math.PI/180:i[e]=720/21*(Math.PI/180)}let r,l,c,d,h,u=0;for(let e=0;e<20;e++)u+=i[e];for(let e=0;e<i.length;e++)e%21==20&&(i[e]=720*Math.PI/180-u);if(s.num%2==0)r=new e.Vector3(s.col*Math.sqrt(3)*x/2,3*s.row*x/2,0),l=t.clone(),c=n.clone(),d=0,h=o.generate_or_sq(s.len,void 0,r,l,c,!0,d,i);else{r=new e.Vector3(s.col*Math.sqrt(3)*x/2,3*s.row*x/2+1.275,(s.len-1)*a),l=t.clone().negate(),c=n.clone().negate(),d=-v(...i)%(2*Math.PI);let u=i.slice().reverse();h=o.generate_or_sq(s.len,void 0,r,l,c,!0,d,u)}return[h,i,r,d,l,c]}class ${constructor(){this.vhelices=[]}add_vhelix(e){this.vhelices.push(e)}bbox(){let e=[],t=[],n=[];for(const s of this.vhelices)e.push(s.row),t.push(s.col),n.push(s.stap.length);const s=w*(Math.max(...e)-Math.min(...e)+2),o=w*(Math.max(...t)-Math.min(...t)+2),i=.34*(Math.max(...n)+2);return 2*Math.max(s,o,i)*2}toString(){let e='{\n"vstrands":[\n';if(this.vhelices.length>0){for(const t of this.vhelices)e+=`${t},`;e=e.slice(0,e.length-1)}return e+="}\n",e}}class S{constructor(){this.stapLoop=[],this.scafLoop=[],this.skip=[],this.loop=[],this.stap_colors=[],this.row=0,this.col=0,this.num=0,this.stap=[],this.scaf=[],this.cad_index=-1,this.skiploop_bases=0}get len(){return Math.max(this.scaf.length,this.stap.length)}add_square(e,t){"stap"===t?this.stap.push(e):"scaf"===t?this.scaf.push(e):l.log("Cannot add square that is not scaf or stap. Dying now",l.CRITICAL)}toString(){let e="{\n";if(e+='"stapLoop":[',this.stapLoop.length>0){for(const t of this.stapLoop)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"skip":[',this.skip.length>0){for(const t of this.skip)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"loop":[',this.loop.length>0){for(const t of this.loop)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"stap_colors":[',this.stap_colors.length>0){for(const t of this.stap_colors)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+=`"row":${this.row},\n`,e+=`"col":${this.col},\n`,e+=`"num":${this.num},\n`,e+='"scafLoop":[',this.scafLoop.length>0){for(const t of this.scafLoop)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"stap":[',this.stap.length>0){for(const t of this.stap)e+=`${t},`;e=e.slice(0,e.length-1)}if(e+="],\n",e+='"scaf":[',this.scaf.length>0){for(const t of this.scaf)e+=`${t},`;e=e.slice(0,e.length-1)}return e+="]\n}",e}}class P{constructor(e=-1,t=-1,n=-1,s=-1){this.V_0=e,this.b_0=t,this.V_1=n,this.b_1=s}toString(){return`[${this.V_0},${this.b_0},${this.V_1},${this.b_1}]`}type(e,t){if(-1===this.V_0&&-1===this.b_0){if(-1===this.V_1&&-1===this.b_1)return"empty";if(this.V_1===e.num&&1===Math.abs(this.b_1-t))return"begin"}else{if(this.V_0===e.num&&1===Math.abs(this.b_0-t))return-1===this.V_1?"end":this.V_1===e.num&&1===Math.abs(this.b_1-t)?"continue":"end";if(this.V_1===e.num&&1===Math.abs(this.b_1-t))return"begin"}l.log("unexpected square array",l.WARNING)}}function R(e,t,n){let s=.4*parseFloat(n)/2;return e.clone().sub(t.clone().multiplyScalar(s))}function z(t,n,s,o){let i;switch(n){case"cadnano":i=function(t,n,s,o){let i=!1,r=!1;if("sq"===n)i=!0;else{if("he"!==n)return void alert("Lattice_type should be either 'sq' or 'he'");r=!0}let a=new y,p=new y,f=function(e){let t=new $,n=JSON.parse(e);for(const e of n.vstrands){let n=new S;for(const[t,s]of Object.entries(e))"skip"===t?n.skip=s.map((e=>Math.abs(e))):n[t]="stap"===t||"scaf"===t?s.map((e=>new P(...e))):s;n.skiploop_bases=n.skip.length+v(...n.loop)-v(...n.skip),t.add_vhelix(n)}return t}(t),g=!1,m=!0;if(!s){l.log("No sequences given, using random sequence",l.INFO),s=[];for(let e=0;e<f.vhelices.length;e++){let t=[];for(let n=0;n<f.vhelices[e].skiploop_bases;n++)t.push(u(0,4));s.push(t)}}1===s.length&&f.vhelices.length>1&&(l.log("One line detected in the sequence file. Since the cadnano file contains more than 1 virtual helix, the sequence found will be used as we were dealing with a single-strand system",l.INFO),g=!0,m=!1);let x=0;void 0===o&&(o=f.bbox(),l.log("Using default box size, a factor 2 larger than the size of the cadnano system",l.INFO));let w=new e.Vector3(0,0,1),N=new e.Vector3(1,0,0);var R;i?(R=w,N=N.clone().applyAxisAngle(R,15*Math.PI/180)):r&&(N=function(e,t){return t.clone().applyAxisAngle(e,160*Math.PI/180)}(w,N));let z=new h(new e.Vector3(o,o,o)),G=new h(new e.Vector3(o,o,o)),W=-1,C=[],F=[],L=!1,O=[],E=[],T=-1,j=-1;for(const e of f.vhelices){let t,n,o,c,d,h;e.cad_index=x,i?[t,n,o,c,d,h]=q(w,N,e):r&&([t,n,o,c,d,h]=k(w,N,e));let u=V(e),p=0;for(const t of e.scaf){if(-1===t.V_0&&-1===t.b_0)-1===t.V_1&&-1===t.b_0||(t.V_1===e.num&&1===Math.abs(t.b_1-p)?(e.num%2==0&&W++,T=p,e.num%2==1&&(z=I(z,e,T,j,u,0,o,d,h,c,n,0,m,s),a=A(e,W,T,j,a,2))):l.log("unexpected square array",l.WARNING));else if(t.V_0===e.num&&1===Math.abs(t.b_0-p))if(-1===t.V_1&&-1===t.b_1)e.num%2==1&&W++,j=p,e.num%2==0&&(z=I(z,e,T,j,u,0,o,d,h,c,n,0,m,s),a=A(e,W,T,j,a,2));else if(t.V_1===e.num&&1===Math.abs(t.b_1-p));else{let i;e.num%2==1&&W++,j=p,e.num%2==0&&(z=I(z,e,T,j,u,0,o,d,h,c,n,0,m,s),a=A(e,W,T,j,a,2)),e.num,i=p;for(let t=0;t<C.length;t++)_([e.num,i],C[t])&&(O[t].splice(0,0,W),L=!0);L||(O.push([W]),C.push([t.V_1,t.b_1])),L=!1}else if(-1===t.V_1&&-1===t.b_1)l.log("unexpected square array",l.WARNING);else if(t.V_1===e.num&&1===Math.abs(t.b_1-p)){e.num%2==0&&W++,T=p,e.num%2==1&&(z=I(z,e,T,j,u,0,o,d,h,c,n,0,m,s),a=A(e,W,T,j,a,2));for(let t=0;t<C.length;t++){let n;e.num,n=p,_([e.num,n],C[t])&&(O[t].push(W),L=!0)}L||(O.push([W]),C.push([t.V_0,t.b_0])),L=!1}else l.log("unexpected square array",l.WARNING);p++}if(0!==z.N_strands){p=0;for(const t of e.stap){if(-1===t.V_0&&-1===t.b_0)-1===t.V_1&&-1===t.b_0||(t.V_1===e.num&&1===Math.abs(t.b_1-p)?(e.num%2==1&&W++,T=p,e.num%2==0&&(z=I(z,e,T,j,u,0,o,d,h,c,n,1,m,s),a=A(e,W,T,j,a,3))):l.log("unexpected square array",l.WARNING));else if(t.V_0===e.num&&1===Math.abs(t.b_0-p))if(-1===t.V_1&&-1===t.b_1)e.num%2==0&&W++,j=p,e.num%2==1&&(z=I(z,e,T,j,u,0,o,d,h,c,n,1,m,s),a=A(e,W,T,j,a,3));else if(t.V_1===e.num&&1===Math.abs(t.b_1-p));else{e.num%2==0&&W++,j=p,e.num%2==1&&(z=I(z,e,T,j,u,0,o,d,h,c,n,1,m,s),a=A(e,W,T,j,a,3));let i=p;for(let t=0;t<F.length;t++)_([e.num,i],F[t])&&(E[t].splice(0,0,W),L=!0);L||(E.push([W]),F.push([t.V_1,t.b_1])),L=!1}else if(-1===t.V_1&&-1===t.b_1)l.log("unexpected square array",l.WARNING);else if(t.V_1===e.num&&1===Math.abs(t.b_1-p)){e.num%2==1&&W++,T=p,e.num%2==0&&(z=I(z,e,T,j,u,0,o,d,h,c,n,1,m,s),a=A(e,W,T,j,a,3));for(let t=0;t<F.length;t++){let n=p;_([e.num,n],F[t])&&(E[t].push(W),L=!0)}L||(E.push([W]),F.push([t.V_0,t.b_0])),L=!1}else l.log("unexpected square array",l.WARNING);p++}x++}else l.log(`No scaffold strand found in virtual helix n. ${e.num}: staples-only virtual helices are not supported`,l.WARNING)}let D,U=[O,E],Q=[];for(let e=0;e<2;e++)for(const t of U[e])Q.push(...t);for(let e=0;e<z._strands.length;e++)Q.includes(e)||(G.add_strand(z._strands[e]),p.add_strand(e,a));for(let e=0;e<2;e++){const t=U[e];let n=!1;D=!1;for(const e of t){let t=z._strands[e[0]],n=z._strands[e[1]],s=t._nucleotides.slice(-1)[0].distance(n._nucleotides[0],!1),o=Math.sqrt(s.dot(s));(o>1.0018||o<.5525)&&l.log(`The backbone-backbone distance across joints is ${o}: it will have to be relaxed with preliminary simulations`,l.WARNING)}let o=[];for(;!n;){D=!1;for(let e=0;e<t.length&&!D;e++)for(let n=0;n<t.length&&!D;n++)if(t[e][0]===t[n].slice(-1)[0]){if(e!=n){t[n].push(...t[e].slice(1)),t.splice(e,1),D=!0;break}o.includes(e)||o.push(e)}D||(n=!0)}for(let e=0;e<t.length;e++){const n=t[e];let i,r=z._strands[n[0]];if(o.includes(e)){for(const e of M(1,n.length-1))r=r.append(z._strands[n[e]]);r.make_circular(!0)}else for(const e of M(1,n.length))r=r.append(z._strands[n[e]]);G.add_strand(r),i=r._circular?M(n.length-2):M(n.length-1);for(const e of i)p.add_strand(n[e],a,!0);p.add_strand(n[i[i.length-1]+1],a,!1),g&&(G._strands[0].sequence=s[0])}}let B=new h(G._box);for(const e of G._strands){let t=e._nucleotides.map((e=>e));t.reverse();let n=new d;for(const e of t)n.add_nucleotide(new c(e.cm_pos,e._a1,e._a3.clone().negate(),e._base));e._circular&&n.make_circular(),B.add_strand(n)}let H=new y,J=M(B._N_strands),K=0;for(let e=0;e<B._strands.length;e++){const t=B._strands[e];J[e]=K,K+=t._nucleotides.length}let X=new Map;for(const[e,t]of p._scaf.keys()){let[n,s]=p._scaf.get([e,t]),o=[];for(const i of s){const s=B._strands[n]._nucleotides.length-1-(i-J[n])+J[n];o.push(s),X.set(s,[e,t])}H.add_scaf(e,t,n,o)}for(const[e,t]of p._stap.keys()){let[n,s]=p._stap.get([e,t]),o=[];for(const i of s){const s=B._strands[n]._nucleotides.length-1-(i-J[n])+J[n];o.push(s),X.set(s,[e,t])}H.add_stap(e,t,n,o)}if(0===B.N)return void l.log("The generated configuration is empty: this might be due to this conversion module not supporting virtual helices containing no scaffold strands.",l.CRITICAL);let Y=new b;for(const e of f.vhelices)for(const[t,n]of e.stap_colors)Y.set([e.num,t],n);let Z=new b;for(const[e,t]of X.entries())Z.has(t)||Z.set(t,[]),Z.get(t).push(e);let ee=new Map;for(const e of B._strands)for(const t of e._nucleotides)ee.set(t.index,t);let te=[];for(const e of Z.values())for(const t of e)try{te.push(ee.get(t).strand)}catch(e){console.log(`Could not find nucId ${t} strand`)}let ne=(se=te,oe={},se.forEach((function(e){oe[e]=(oe[e]||0)+1})),Object.keys(oe).reduce((function(e,t,n){return!n||oe[t]>oe[e[0]]?[t]:(oe[t]===oe[e[0]]&&e.push(t),e)}),[]))[0];var se,oe;let ie=new Map;for(const e of B._strands)for(const t of e._nucleotides)if(X.has(t.index)){let[e,n]=X.get(t.index),s=Z.get([e,n]);s.length>1&&(t.pair=ee.get(s.filter((e=>e!=t.index))[0]));let o=Z.get([e,n]).filter((e=>ee.get(e).strand!=ne));if(o.length>0){let s=ee.get(o[0]);const i=[e,s.strand];ie.has(i)||ie.set(i,ie.size+1),t.cluster=ie.get(i),t===s?Y.has([e,n])&&(t.color=Y.get([e,n])):t.color=3633362}else t.cluster=-1}for(const e of B._strands)for(const t of e._nucleotides)if(void 0!==t.color){for(const n of e._nucleotides)n.color=t.color;break}return B}(t[0],o.grid,o.sequences,o.side);break;case"rpoly":i=function(t){let n=[],s=[],o=[],i=0;for(const e of t.split("\n"))e.startsWith("hb")?(n.splice(i,0,e.split(" ")),i+=1):e.startsWith("c")&&(e.includes("f3")?o.push([parseInt(e.match(/c helix_(.+?) /)[1]),parseInt(e.match(/\' helix_(.+?) /)[1])]):s.push([parseInt(e.match(/c helix_(.+?) /)[1]),parseInt(e.match(/\' helix_(.+?) /)[1])]));let r=new m,a=new h(new e.Vector3(100,100,100)),l=new h(new e.Vector3(100,100,100)),c=0;for(let t=0;t<n.length;t++){const s=n[t];let o=new e.Vector3(parseFloat(s[3])/.84,parseFloat(s[4])/.84,parseFloat(s[5])/.84),i=parseInt(s[2]),d=new e.Quaternion(parseFloat(s[6]),parseFloat(s[7]),parseFloat(s[8]),parseFloat(s[9])),h=new e.Vector3(0,0,1).applyQuaternion(d),u=new e.Vector3(.65,-.76,0).applyQuaternion(d),_=R(o,h,i);for(const e of _.toArray())e>c&&(c=e);let p=r.generate_or_sq(i,void 0,_,h,u);for(const e of[0,1])for(const n of p[e]._nucleotides)n.cluster=t+1;let[f,g]=p[1].cut_in_two(!1);a.add_strand(f),a.add_strand(g),l.add_strand(p[0])}let d=new h(new e.Vector3(3*c,3*c,3*c));for(const e of s){let t=2*e[0]-1,n=2*e[1]-2,s=a._strands[t];s=s.append(a._strands[n]),d.add_strand(s)}let u=l._strands[0];for(const e of o.slice(0,-1)){let t=e[1]-1,n=l._strands[t];u=u.append(n)}return u.make_circular(),d.add_strand(u),d}(t[0]);break;default:return void console.log("Unknown input format: "+n)}switch(s){case"oxview":return i.print_oxview_output();case"oxdna":return i.print_lorenzo_output();default:console.log("Unknown output format: "+n)}}async function G(e,t,n,s){const o=new Worker("./src/libs/conversionWorker",{type:"module"});return new Promise(((i,r)=>{try{o.onmessage=e=>{i(e.data),o.terminate()},o.onerror=e=>{r(e),o.terminate()},o.postMessage([e,t,n,s])}catch(e){r(e)}}))}})(),o})()}));